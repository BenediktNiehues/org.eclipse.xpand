grammar Xpand3Node;

file  :
	(imports+=nsImport)*
	(declarations+=abstractDeclaration)*
	 EOF
;

abstract normalizable nsImport:
	import | extensionImport 
;

import:
	(LG 'IMPORT' namespace=simpleType RG) |
	'import' type=type  ';' 
; 
	
extensionImport:
	(LG 'EXTENSION' namespace=simpleType RG) |
	'extension' type=type 'reexport'? ';' 
;

abstract normalizable abstractDeclaration :
	check |
	around |
	extension |
	definition |
	definitionAround
;

// XPAND start

definition :
	LG DEFINE name=identifier ('(' (paramList=declaredParameterList (','? '*')? | '*')? ')')? 'FOR' type=type
	sequence=sequence
	ENDDEFINE RG
;
	
definitionAround :	
	LG AROUND pointcut=pointcut ('(' (paramList=declaredParameterList (','? '*')? | '*')? ')')? 'FOR' type=type
	sequence=sequence
	ENDAROUND RG
;	

sequence :
	 textSequences+=textSequence 
	 (statements+=statement 
	  textSequences+=textSequence)*		
;

abstract normalizable statement :
  simpleStatement 
| fileStatement 
| foreachStatement 
| ifStatement 
| letStatement 
| protectStatement
;
	
normalizable textSequence :
	texts+=text (texts+=text)*
;

text :
	'-'? TEXT
;

abstract normalizable simpleStatement :
  errorStatement
| expandStatement
| expressionStmt
;

errorStatement :
  'ERROR' expression=expression
;

expandStatement :
  'EXPAND' name=simpleType ('(' paramList=parameterList ')')? (('FOR' forExpression=expression)
  | ('FOREACH' forEachExpression=expression ('SEPARATOR' separator=expression)?))?
;

expressionStmt  :
	expression=expression
;

fileStatement :
	'FILE' nameExpression=expression ('ONCE')? (identifier=identifier)? 
		sequence=sequence 
	'ENDFILE'
;
	
foreachStatement :
	 'FOREACH' forExpression=expression 'AS' identifier=identifier ('ITERATOR' iterator=identifier)? ('SEPARATOR' separatorExpression=expression)?
  		sequence=sequence 
	 'ENDFOREACH'
;

ifStatement : 
     'IF' expression=expression
		sequence=sequence 
	 elseIfs+=elseIfStatement*
	 else=elseStatement?
	 'ENDIF'
;

elseIfStatement :
	'ELSEIF' expression=expression
		sequence=sequence 
;
	
elseStatement :
	'ELSE'
		sequence=sequence
;
	
letStatement :
	 'LET' expression=expression 'AS' name=identifier
  		sequence=sequence 
	 'ENDLET'
;
	
protectStatement :
	'PROTECT' 
		'CSTART' cstart=expression 
		'CEND' cend=expression 
         	'ID' id=expression 'DISABLE'?
 		sequence=sequence 
	'ENDPROTECT'
;

// Xtend start

check :
	'context' type=type ('if' ifExpression=expression)? (error='ERROR'|warning='WARNING') message=expression ':'
		constraint=expression ';'	
;

around  :
    'around' pointcut '(' (declaredParameterList (','? '*')? | '*')? ')' ':'
    	expression ';'
;
    
pointcut  :
	( '*' 
	 |identifier)
	  ( '*' 
	   |identifier 
	   |'::' )*
;

extension  : // TODO create <identifier> <name< (...)
	(private='private'|cached='cached'|create='create')* 
	returnType=type? name=identifier '(' paramList=declaredParameterList? ')' ':'
		('JAVA' javaReturnType=javaType '.' javaName=identifier '('(javaType (',' javaType )*)? ')'|	
			extendBody=expression )';'
;

javaType  :
	identifier  
	('.' (identifier |'Collection' | 
	'List' |'Set'))*
;

//
// Expressions
//

normalizable test_expression:	
 	expression EOF
;

abstract normalizable expression :
	letExpression
;

normalizable letExpression  :
   'let' identifier '=' castedExpression ':' expression 
|  castedExpression 
;

normalizable castedExpression :
    =>('(' type ')' chainExpression)
	'(' type=type ')' target=chainExpression 
	| chainExpression 
;

normalizable chainExpression  :
	first=ifExpression  ( '->' nexts+=ifExpression )*
;

normalizable ifExpression  :
	condition0=switchExpression ('?' then=expression ':' else=switchExpression )?
|	'if' condition1=expression 'then' then=switchExpression ('else' else=switchExpression)? 
;

normalizable switchExpression  :
   'switch' ('(' expression=orExpression ')')? '{'
	cases+=casePart*
   'default' ':' default=orExpression
   '}'
|  orExpression 
;

casePart :
	'case' condition=expression ':' expression=expression;	

normalizable orExpression :
  	first=andExpression ('||' nexts+=andExpression )*	
;

normalizable andExpression 	:
	first=impliesExpression  ('&&' nexts+=impliesExpression)*	
;

normalizable impliesExpression :
	first=relationalExpression  ('implies' nexts+=relationalExpression)*	
;
	
normalizable relationalExpression :
	first=additiveExpression 
	( ('==' | '!=' | '>=' | '<=' | '>' | '<' ) nexts+=additiveExpression )*
;

normalizable additiveExpression :
	first=multiplicativeExpression 
   (('+'| '-') nexts+=multiplicativeExpression )*
;

normalizable multiplicativeExpression :
	first=unaryExpression 
	(('*' | '/') nexts+=unaryExpression )*
;


normalizable unaryExpression :
	infixExpression 
|	'!' operand=infixExpression	
|	'-' operand=infixExpression	
;

normalizable infixExpression :
	target=primaryExpression  ( '.' calls+=featureCall )*
;
	
abstract normalizable primaryExpression 	 :
    stringLiteral 	
|   featureCall 
|   booleanLiteral 
|   numberLiteral 
|   nullLiteral 
|   listLiteral 
|   constructorCall 
|   globalVarExpression 
|   paranthesizedExpression 
;

stringLiteral :
  	StringLiteral
;

paranthesizedExpression :
    '(' expression=expression ')' 
;

globalVarExpression  :
    'GLOBALVAR' identifier ;

featureCall  :
	collectionExpression
|   name=identifier '(' (paramList=parameterList)? ')' 
|   type=type 	
   
;

listLiteral  :
	'{'(elements+=expression (',' elements+=expression)*)?'}'
;

constructorCall  :
	'new' simpleType
	
;

booleanLiteral  :
	'false'|'true'
;

nullLiteral  :
	'null'
;

numberLiteral  :
  	IntLiteral 
| 	IntLiteral '.' IntLiteral 
;

collectionExpression  :
  'typeSelect' '(' type=type ')' 
  |('collect'
  | 'select' 
  | 'selectFirst' 
  | 'reject' 
  | 'exists'
  | 'notExists'
  | 'sortBy' 
  | 'forAll') '(' (variable=identifier '|')? expression=expression ')' 
;

// helper

declaredParameterList  : 
	params+=declaredParameter (',' params+=declaredParameter )*
;

declaredParameter :
	ptype=type name=identifier 
;

parameterList  :
    params+=expression  (',' params+=expression )* 
;

// type

abstract normalizable type : 
	collectionType |
	simpleType 
;
	
collectionType  : 
  ( collectionType='Collection' | collectionType='List' | collectionType='Set' ) 
  ('[' elementType=simpleType ']' )?
;

simpleType :
	names+=identifier 
	('::' names+=identifier  )*
;

identifier :
   Identifier 
;


/////////////////////////////////////////
// LEXER
////////////////////////////////////////

lexer IntLiteral :
	<# ('0' | '1'..'9' '0'..'9'*) #>
	
lexer StringLiteral :  
	<# '\"' ( EscapeSequence | ~('\\'|'\"') )* '\"'
    |  '\'' ( EscapeSequence | ~('\''|'\\') )* '\'' #>

lexer fragment EscapeSequence    :
	<# '\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
    |   UnicodeEscape
    |   OctalEscape #>

lexer fragment OctalEscape :   
	<# '\\' ('0'..'3') ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7') #>

lexer fragment UnicodeEscape :
    <# '\\' 'u' HexDigit HexDigit HexDigit HexDigit #>
    
lexer fragment HexDigit : 
	<# ('0'..'9'|'a'..'f'|'A'..'F') #>

lexer DEFINE 	: 
	<# {xpandMode=true;}	 'DEFINE' #>

lexer ENDDEFINE :
	<# 'ENDDEFINE' {xpandMode=false;} #>
	
lexer AROUND 	:	
	<# {xpandMode=true;}'AROUND' #>

lexer ENDAROUND :	<# 'ENDAROUND'{xpandMode=false;} #> 

lexer Identifier : 
	<# ('^')? Letter (Letter|JavaIDDigit)* #>

lexer fragment Letter :
    <# '\u0024' |
       '\u0041'..'\u005a' |
       '\u005f' |
       '\u0061'..'\u007a' |
       '\u00c0'..'\u00d6' |
       '\u00d8'..'\u00f6' |
       '\u00f8'..'\u00ff' |
       '\u0100'..'\u1fff' |
       '\u3040'..'\u318f' |
       '\u3300'..'\u337f' |
       '\u3400'..'\u3d2d' |
       '\u4e00'..'\u9fff' |
       '\uf900'..'\ufaff' #>

lexer fragment JavaIDDigit :  
	<#
       '\u0030'..'\u0039' |
       '\u0660'..'\u0669' |
       '\u06f0'..'\u06f9' |
       '\u0966'..'\u096f' |
       '\u09e6'..'\u09ef' |
       '\u0a66'..'\u0a6f' |
       '\u0ae6'..'\u0aef' |
       '\u0b66'..'\u0b6f' |
       '\u0be7'..'\u0bef' |
       '\u0c66'..'\u0c6f' |
       '\u0ce6'..'\u0cef' |
       '\u0d66'..'\u0d6f' |
       '\u0e50'..'\u0e59' |
       '\u0ed0'..'\u0ed9' |
       '\u1040'..'\u1049'
       #>

lexer WS  :  
	<# (' '|'\r'|'\t'|'\u000C'|'\n') {$channel=HIDDEN;} #>

lexer COMMENT :   
	<# '/*' ( options {greedy=false;} : . )* '*/' {$channel=HIDDEN;} #>

lexer LINE_COMMENT : 
	<# '//' ~('\n'|'\r')* ('\r'? '\n'|EOF) {$channel=HIDDEN;} #>
    
    
lexer REM_COMMENT_OUT :
	<# {!xpandMode}?=> LG 'REM' RG ( options {greedy=false;} : . )* '\u00ABENDREM' RG {$channel=HIDDEN;} #>
    
lexer REM_COMMENT :
	<# {xpandMode}?=> 'REM' RG ( options {greedy=false;} : . )* '\u00ABENDREM' {$channel=HIDDEN;} #>

lexer TEXT :
	<# {xpandMode}?=> RG ~(LG)* (LG)? #>

lexer LG 	: 
	<# '\u00AB' #>
	
lexer RG	: 
	<# '\u00BB' #>	
