<html>
<head>
<title>Type System</title>
<link href="book.css" rel="stylesheet" type="text/css"/>
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator"/>
<link rel="home" href="index.html" title="Xpand Documentation"/>
<link rel="up" href="ch01.html" title="Xpand / Xtend / Check Reference"/>
<link rel="prev" href="ch01.html" title="Xpand / Xtend / Check Reference"/>
<link rel="next" href="ch01s03.html" title="Expressions"/>
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Type System TypeData type TypeParameterized type</h1>
<div class="section" title="Type System">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both">
<a name="r10_typesystem"/>Type System <a name="N1002C" class="indexterm"/> <a name="N10032" class="indexterm"/>
</h2>
</div>
</div>
</div>
<p>The abstraction layer on API basis is called a type system. It
    provides access to built-in types and different registered metamodel
    implementations. These registered metamodel implementations offer access
    to the types they provide. The first part of this documentation describes
    the type system. The expression sub-language is described afterwards in
    the second part of this documentation. This differentiation is necessary
    because the type system and the expression language are two different
    things. The type system is a kind of reflection layer, that can be
    extended with metamodel implementations. The expression language defines a
    concrete syntax for executable expressions, using the type system.</p>
<p>The Java API described here is located in the
    <span class="package">org.eclipse.xpand.type</span> package and is a part of
    the subproject <span class="package">core.expressions</span>.</p>
<div class="section" title="Types">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="r10_typesystem_types"/>Types</h3>
</div>
</div>
</div>
<p>Every object (e.g. model elements, values, etc.) has a type. A
      type contains properties and operations. In addition it might inherit
      from other types (multiple inheritance).</p>
<div class="section" title="Type Names">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_typesystem_typenames"/>Type Names</h4>
</div>
</div>
</div>
<p>Types have a simple name (e.g. <code class="classname">String</code>)
        and an optional namespace used to distingish between two types with
        the same name (e.g. <code class="classname">my::metamodel</code>). The
        delimiter for name space fragments is a double colon
        "<code class="classname">::</code>". A fully qualified name looks like this:
        </p>
<pre class="programlisting">my::fully::qualified::MetaType</pre>
<p>The namespace and name used by a specific type is defined by the
        corresponding <code class="classname">MetaModel</code>
<a name="N1005D" class="indexterm"/> implementation. The <code class="classname">EmfMetaModel<a name="N10063" class="indexterm"/>
</code>, for instance, maps
        <code class="classname">EPackages</code> to namespace and
        <code class="classname">EClassifiers</code> to names.<a name="N1006D" class="indexterm"/> <a name="N10071" class="indexterm"/> Therefore, the name of the Ecore element
        <code class="classname">EClassifier</code> is called:</p>
<pre class="programlisting">ecore::EClassifier</pre>
<p>If you do not want to use namespaces (for whatever reason), you
        can always implement your own metamodel and map the names
        accordingly.</p>
</div>
<div class="section" title="Collection Type Names">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_typesystem_collection_typenames"/>Collection Type Names</h4>
</div>
</div>
</div>
<p>The built-in type system also contains the following collection
        types<a name="N10082" class="indexterm"/>: <code class="classname">Collection</code>,
        <code class="classname">List</code> and <code class="classname">Set</code>. Because
        the expressions language is statically type checked and we do not like
        casts and <code class="classname">ClassCastExceptions</code>, we introduced
        the concept of <span class="emphasis">
<em>parameterized types</em>
</span>. The type
        system does not support full featured generics, because we do not need
        them.</p>
<p>The syntax is:</p>
<pre class="programlisting">Collection[my::Type]
List[my::Type]
Set[my::Type]
</pre>
</div>
<div class="section" title="Features">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_typesystem_features"/>Features</h4>
</div>
</div>
</div>
<p>Each type offers features. The type (resp. the metamodel) is
        responsible for mapping the features. There are three different kinds
        of features: </p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>Properties</p>
</li>
<li class="listitem">
<p>Operations</p>
</li>
<li class="listitem">
<p>Static properties</p>
</li>
</ul>
</div>
<p>
<span class="emphasis">
<em>Properties</em>
</span>
<a name="N100AC" class="indexterm"/> are straight forward: They have a name and a type. They
        can be invoked on instances of the corresponding type. The same is
        true for <span class="emphasis">
<em>Operations</em>
</span>
<a name="N100B4" class="indexterm"/>. But in contrast to properties, they can have
        parameters. <span class="emphasis">
<em>Static properties</em>
</span> <a name="N100BD" class="indexterm"/>are the equivalent to enums or constants. They must be
        invoked statically and they do not have parameters.</p>
</div>
</div>
<div class="section" title="Built-In Types">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="r10_builtintypes"/>Built-In Types<a name="N100C7" class="indexterm"/>
</h3>
</div>
</div>
</div>
<p>As mentioned before, the expressions framework has several
      built-in types that define operations and properties. In the following,
      we will give a rough overview of the types and their features. We will
      not document all of the operations here, because the built-in types will
      evolve over time and we want to derive the documentation from the
      implementation (model-driven, of course). For a complete reference,
      consult the generated API documentation (<a class="ulink" href="http://www.openarchitectureware.org/api/built-ins/" target="_new">http://www.openarchitectureware.org/api/built-ins/</a>).</p>
<div class="section" title="Object">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_builtintypes_object"/>
<code class="classname">Object<a name="N100D5" class="indexterm"/>
</code>
</h4>
</div>
</div>
</div>
<p>
<code class="classname">Object</code> defines a couple of basic
        operations, like <code class="methodname">equals()</code>. Every type has to
        extend <code class="classname">Object</code>.</p>
</div>
<div class="section" title="Void">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_builtintypes_void"/>
<code class="classname">Void</code>
<a name="N100E9" class="indexterm"/>
</h4>
</div>
</div>
</div>
<p>The <code class="classname">Void</code> type can be specified as the
        return type for operations, although it is not recommended, because
        whenever possible expressions should be free of side effects whenever
        possible.</p>
</div>
<div class="section" title="Simple types (Data types)">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_builtintypes_simple"/>Simple types (Data types)</h4>
</div>
</div>
</div>
<a name="N100F7" class="indexterm"/>
<p>The type system doesn't have a concept data type. Data types are
        just types. As in OCL, we support the following types:
        <code class="classname">String</code>, <code class="classname">Boolean</code>,
        <code class="classname">Integer</code>, <code class="classname">Real</code>.
        </p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
<code class="classname">String</code>
<a name="N1010F" class="indexterm"/>: A rich and convenient
        <code class="classname">String</code> library is especially important
        for code generation. The type system supports the '+' operator
        for concatenation, the usual
        <code class="classname">java.lang.String</code> operations
        (<code class="methodname">length()</code>, etc.) and some special
        operations (like <code class="methodname">toFirstUpper()</code>,
        <code class="methodname">toFirstLower()</code>, regular expressions,
        etc. often needed in code generation templates).</p>
</li>
<li class="listitem">
<p>
<code class="classname">Boolean</code>
<a name="N10126" class="indexterm"/>: <code class="classname">Boolean</code>
        offers the usual operators (Java syntax): &amp;&amp;, ||, !,
        etc.</p>
</li>
<li class="listitem">
<p>
<code class="classname">Integer</code>
<a name="N10131" class="indexterm"/> and
        <code class="classname">Real</code>
<a name="N10137" class="indexterm"/>: <code class="classname">Integer</code>
        and <code class="classname">Real</code> offer the usual compare
        operators (&lt;,&gt;,&lt;=,&gt;=) and simple arithmetics
        (+,-,*,/). Note that <span class="emphasis">
<em>
<code class="classname">Integer</code>
          extends <code class="classname">Real</code>!</em>
</span>
</p>
</li>
</ul>
</div>
</div>
<div class="section" title="Collection types">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_builtintypes_collections"/>Collection types</h4>
</div>
</div>
</div>
<a name="N1014C" class="indexterm"/>
<p>The type system has three different Collection types.
        <code class="classname">Collection</code>
<a name="N10155" class="indexterm"/> is the base type, it provides several operations known
        from <code class="classname">java.util.Collection</code>. The other two types
        (<code class="classname">List</code>
<a name="N1015E" class="indexterm"/>, <code class="classname">Set<a name="N10164" class="indexterm"/>
</code>) correspond to their
        <span class="package">java.util</span> equivalents, too.</p>
</div>
<div class="section" title="Type system types">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_builtintypes_typesystem_types"/>Type system types</h4>
</div>
</div>
</div>
<p>The type system describes itself, hence, there are types for the
        different concepts. These types are needed for reflective programming.
        To avoid confusion with metatypes with the same name (it is not
        unusual to have a metatype called <code class="classname">Operation</code>,
        for instance) we have prefixed all of the types with the namespace
        <code class="classname">xpand</code>. We have:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
<code class="classname">xpand2::Type</code>
</p>
</li>
<li class="listitem">
<p>
<code class="classname">xpand2::Feature</code>
</p>
</li>
<li class="listitem">
<p>
<code class="classname">xpand2::Property</code>
</p>
</li>
<li class="listitem">
<p>
<code class="classname">xpand2::StaticProperty</code>
</p>
</li>
<li class="listitem">
<p>
<code class="classname">xpand2::Operation</code>
</p>
</li>
</ul>
</div>
</div>
</div>
<div class="section" title="Metamodel Implementations (also known as Meta-Metamodels)">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="r10_metamodel_implementations"/>Metamodel Implementations (also known as
      Meta-Metamodels)<a name="N10190" class="indexterm"/>
</h3>
</div>
</div>
</div>
<p>By default, the type system only knows the built-in types. In
      order to register your own metatypes (e.g. <code class="classname">Entity</code>
      or <code class="classname">State</code>), you need to register a respective
      metamodel implementation with the type system. Within a metamodel
      implementation the <span class="emphasis">
<em>Xpand</em>
</span> type system elements (Type, Property, <a name="N1019E" class="indexterm"/> Operation) <a name="N101A2" class="indexterm"/> are mapped to an arbitrary other type system (Java
      reflections, Ecore or XML Schema).</p>
<div class="section" title="Example JavaMetaModel">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_metamodel_example_java"/>Example JavaMetaModel</h4>
</div>
</div>
</div>
<p>For instance, if you want to have the following JavaBean act as
        a metatype (i.e. your model contains instances of the type):</p>
<pre class="programlisting">public class Attribute {
   private String name;
   private String type;
   public String getName() {
      return name;
   }
   public void setName(String name) {
      this.name = name;
   }
   public String getType() {
      return type;
   }
   public void setType(String type) {
      this.type = type;
   }
}
</pre>
<p>You need to use the <code class="classname">JavaMetaModel</code>
        <a name="N101B4" class="indexterm"/> implementation which uses the ordinary Java reflection
        layer in order to map access to the model.</p>
<p>So, if you have the following expression in e.g.
        <span class="emphasis">
<em>Xpand</em>
</span>:</p>
<pre class="programlisting">myattr.name.toFirstUpper()</pre>
<p>and <code class="varname">myattr</code> is the name of a local variable
        pointing to an instance of <code class="classname">Attribute</code>. The <span class="emphasis">
<em>Xpand</em>
</span>
        type system asks the metamodel implementations, if they 'know' a type
        for the instance of Attribute. If you have the
        <code class="classname">JavaMetaModel</code> registered it will return an
        <code class="classname">xpand2::Type</code> which maps to the underlying Java
        class. When the type is asked if it knows a property
        '<code class="varname">name</code>', it will inspect the Java class using the
        Java reflection API.</p>
<p>The JavaMetaModel implementation shipped with <span class="emphasis">
<em>Xpand</em>
</span> can be
        configured with a strategy [GOF95-Pattern] in order to control or
        change the mapping. For instance, the JavaBeansStrategy maps getter
        and setter methods to simple properties, so we would use this strategy
        for the example above.</p>
</div>
<div class="section" title="Eclipse IDE MetaModelContributors">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_metamodel_contributors"/>Eclipse IDE MetaModelContributors</h4>
</div>
</div>
</div>
<p>You should know that for each <code class="classname">Metamodel</code>
        <a name="N101E1" class="indexterm"/>implementation you use at runtime, you need to have a so
        called <code class="classname">MetamodelContributor</code> extension for the
        plugins to work with. If you just use one of the standard metamodel
        implementations (EMF, UML2 or Java) you don't have to worry about it,
        since <span class="emphasis">
<em>Xpand</em>
</span> is shipped with respective MetamodelContributors (see the
        corresponding docs for details). If you need to implement your own
        <code class="classname">MetamodelContributor</code>
<a name="N101ED" class="indexterm"/> you should have a look at the Eclipse plug-in reference
        doc.</p>
</div>
<div class="section" title="Configuring Metamodel implementations with the workflow">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_metamodel_workflow"/>Configuring Metamodel implementations with the workflow</h4>
</div>
</div>
</div>
<p>You need to configure your <span class="emphasis">
<em>Xpand</em>
</span> language components with the
        respective metamodel implementations.</p>
<p>A possible configuration of the <code class="classname">Xpand2</code>
        generator component looks like this:</p>
<pre class="programlisting">&lt;component class="org.eclipse.xpand2.Generator"&gt;
   &lt;metaModel class="org.eclipse.type.emf.EmfMetaModel"&gt;
      &lt;metaModelPackage value="my.generated.MetaModel1Package"/&gt;
   &lt;/metaModel&gt;
   &lt;metaModel class="org.eclipse.type.emf.EmfMetaModel"&gt;
      &lt;metaModelFile value="my/java/package/metamodel2.ecore"/&gt;
   &lt;/metaModel&gt;
   ...
&lt;/component&gt;
</pre>
<p>In this example the <code class="classname">EmfMetaModel</code>
        implementation is configured two times. This means that we want to use
        two metamodels at the same time, both based on EMF. The
        <span class="property">metaModelPackage</span> property is a property that is
        specific to the <code class="classname">EmfMetaModel</code> (located in the
        <code class="filename">core.emftools</code> project). It points to the
        generated <code class="classname">EPackages</code> interface. The second meta
        model is configured using the Ecore file. You do no need to have a
        generated Ecore model for <span class="emphasis">
<em>Xpand</em>
</span> in order to work. The
        <code class="classname">EmfMetaModel</code> works with dynamic EMF models just
        as it works with generated EMF models.</p>
</div>
</div>
<div class="section" title="Using different Metamodel implementations (also known as Meta-Metamodels)">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="r10_using_different_metamodels"/>Using different Metamodel implementations (also known as
      Meta-Metamodels)</h3>
</div>
</div>
</div>
<p>With Xpad you can work on different kinds of Model representations
      at the same time in a transparent manner. One can work with EMF models,
      XML DOM models, and simple JavaBeans in the same <span class="emphasis">
<em>Xpand</em>
</span> template. You
      just need to configure the respective MetaModel implementations.</p>
<p>If you want to do so you need to know how the type lookup works.
      Let us assume that we have an EMF metamodel <a name="N10224" class="indexterm"/> and a model based on some Java classes. Then the
      following would be a possible configuration:</p>
<pre class="programlisting">&lt;component class="org.eclipse.xpand2.Generator"&gt;
   &lt;metaModel class="org.eclipse.internal.xtend.type.impl.java.JavaMetaModel"/&gt;
   &lt;metaModel class="org.eclipse.xtend.typesystem.emf.EmfMetaModel"&gt;
      &lt;metaModelFile value="my/java/package/metamodel.ecore"/&gt;
   &lt;/metaModel&gt;

   ...
&lt;/component&gt;
</pre>
<p>When the runtime needs to access a property of a given object,
      it asks the metamodels in the configured order. Let us assume that our
      model element is an instance of the Java type
      <code class="classname">org.eclipse.emf.ecore.EObject</code> and it is a dynamic
      instance of an EMF EClass <code class="classname">MyType</code>.</p>
<p>We have <span class="emphasis">
<em>three</em>
</span> Metamodels: </p>
<div class="orderedlist">
<a name="N10239" class="indexterm"/>
<ol class="orderedlist" type="1">
<li class="listitem">
<p>Built-Ins (always the first one)</p>
</li>
<li class="listitem">
<p>JavaMetaModel</p>
</li>
<li class="listitem">
<p>EMFMetaModel - metamodel.ecore</p>
</li>
</ol>
</div>
<p>The first one will return the type <code class="classname">Object</code>
      (not <code class="classname">java.lang.Object</code> but
      <code class="classname">Object</code> of <span class="emphasis">
<em>Xpand</em>
</span>). At this point the type
      <code class="classname">Object</code> best fits the request, so it will act as
      the desired type.</p>
<p>The second metamodel returns a type called
      <code class="classname">org::eclipse::emf::ecore::EObject</code> The type system
      will check if the returned type is a specialization of the current
      'best-fit' type (<code class="classname">Object</code>). It is, because it
      extends <code class="classname">Object</code> (Every metatype has to extend
      <code class="classname">Object</code>). At this time the type system assumes
      <code class="classname">org::eclipse::emf::ecore::EObject</code> to be the
      desired type.</p>
<p>The third metamodel will return
      <code class="classname">metamodel::MyType</code> which is the desired type. But
      unfortunately it doesn't extend
      <code class="classname">org::eclipse::emf::ecore::EObject</code> as it has
      nothing to do with those Java types. Instead it extends
      <code class="classname">emf::EObject</code> which extends
      <code class="classname">Object</code>.</p>
<p>We need to swap the configuration of the two metamodels to get the
      desired type.</p>
<pre class="programlisting">&lt;component class="org.eclipse.xpand2.Generator"&gt;
   &lt;metaModel class="org.eclipse.xtend.typesystem.emf.EmfMetaModel"&gt;
      &lt;metaModelFile value="my/java/package/metamodel.ecore"/&gt;
   &lt;/metaModel&gt;
   &lt;metaModel class="org.eclipse.internal.xtend.type.impl.java.JavaMetaModel"/&gt;

   ...
&lt;/component&gt;</pre>
</div>
</div>
</body>
</html>
