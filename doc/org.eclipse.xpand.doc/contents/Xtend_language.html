<html>
<head>
<title>Xtend</title>
<link href="../book.css" rel="stylesheet" type="text/css"/>
<meta content="DocBook XSL Stylesheets V1.73.2" name="generator"/>
<link rel="start" href="index.html" title="Check / Xtend / Xpand Reference"/>
<link rel="up" href="index.html" title="Check / Xtend / Xpand Reference"/>
<link rel="prev" href="Check_language.html" title="Check"/>
<link rel="next" href="xpand_reference_introduction.html" title="Xpand2"/>
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<p>Like the expressions sublanguage that summarizes the syntax of expressions for
      all the other textual languages delivered with the openArchitectureWare
      framework, there is another commonly used language called
      <span class="emphasis">
<em>Xtend</em>
</span>.</p>
<p>This language provides the possibility to define rich libraries of independent
      operations and no-invasive metamodel extensions based on either Java methods or oAW
      expressions. Those libraries can be referenced from all other textual languages,
      that are based on the expressions framework.</p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N104BA"/>Extend files</h3>
</div>
</div>
</div>
<p>An extend file must reside in the Java class path of the used execution context.
        Additionally it is file extension must be <code class="filename">*.ext</code>. Let us
        have a look at an extend file.</p>
<pre class="programlisting">import my::metamodel;extension other::ExtensionFile;
      /** * Documentation */ anExpressionExtension(String stringParam) :
      doingStuff(with(stringParam)) ;
      /** * java extensions are just mappings */ String aJavaExtension(String param) :
      JAVA my.JavaClass.staticMethod(java.lang.String) ; </pre>
<p>The example shows the following statements:</p>
<div class="orderedlist">
<ol type="1">
<li>
<p>import statements</p>
</li>
<li>
<p>extension import statements</p>
</li>
<li>
<p>expression or java extensions</p>
</li>
</ol>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N104D0"/>Comments</h3>
</div>
</div>
</div>
<p>We have single- and multi-line comments. The syntax for single line comments
        is:</p>
<pre class="programlisting">// my comment</pre>
<p>Multi line comments are written like this:</p>
<pre class="programlisting">/* My multi line comment */</pre>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N104DB"/>Import Statements</h3>
</div>
</div>
</div>
<p>Using the import statement one can import name spaces of different types.(see
        expressions framework reference documentation).</p>
<p>Syntax is:</p>
<pre class="programlisting">import my::imported::namespace;</pre>
<p>Extend does not support static imports or any similar concept. Therefore, the
        following is incorrect syntax:</p>
<pre class="programlisting">import my::imported::namespace::*; // WRONG! import my::Type; //
      WRONG!</pre>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N104E8"/>Extension Import Statement</h3>
</div>
</div>
</div>
<p>You can import another extend file using the extension statement. The syntax
        is:</p>
<pre class="programlisting">extension
      fully::qualified::ExtensionFileName;</pre>
<p>Note, that no file extension ( <code class="filename">*.ext</code>) is
        specified.</p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N104F4"/>Reexporting Extensions</h4>
</div>
</div>
</div>
<p>If you want to export extensions from another extension file together with
          your local extensions, you can add the keyword 'reexport' to the end of the
          respective extension import statement.</p>
<pre class="programlisting">extension fully::qualified::ExtensionFileName
        reexport;</pre>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N104FB"/>Extensions</h3>
</div>
</div>
</div>
<p>The syntax of a simple expression extension is as follows:</p>
<pre class="programlisting">ReturnType extensionName(ParamType1 paramName1,
      ParamType2...): expression-using-params;</pre>
<p>Example:</p>
<pre class="programlisting">String getterName(NamedElement ele) :
      'get'+ele.name.firstUpper();</pre>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10506"/>Extension Invocation</h4>
</div>
</div>
</div>
<p>There are two different ways of how to invoke an extension. It can be invoked
          like a function:</p>
<pre class="programlisting">getterName(myNamedElement)</pre>
<p>The other way to invoke an extension is through the "member syntax":</p>
<pre class="programlisting">myNamedElement.getterName()</pre>
<p>For any invocation in member syntax, the target expression (the member) is
          mapped to the first parameter. Therefore, both syntactical forms do the same
          thing.</p>
<p>It is important to understand that extensions are not members of the type
          system, hence, they are not accessible through reflection and you cannot
          specialize or overwrite operations using them.</p>
<p>The expression evaluation engine first looks for an appropriate operation
          before looking for an extension, in other words operations have higher
          precedence.</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10517"/>Type Inference</h4>
</div>
</div>
</div>
<p>For most extensions, you do not need to specify the return type, because it
          can be derived from the specified expression. The special thing is, that the
          static return type of such an extension depends on the context of use.</p>
<p>For instance, if you have the following extension</p>
<pre class="programlisting">asList(Object o): {o};</pre>
<p>the invocation of</p>
<pre class="programlisting">asList('text')</pre>
<p>has the static type List[String]. This means you can call</p>
<pre class="programlisting">asList('text').get(0).toUpperCase()</pre>
<p>The expression is statically type safe, because its return type is derived
          automatically.</p>
<p>There is always a return value, whether you specify it or not, even if you
          specify explicitly ' <code class="classname">Void</code>'.</p>
<p>See the following example.</p>
<pre class="programlisting">
        modelTarget.ownedElements.addAllNotNull(modelSource.contents.duplicate())</pre>
<p>In this example duplicate() dispatches polymorphically. Two of the
          extensions might look like:</p>
<pre class="programlisting">Void duplicate(Realization realization):
        realization.Specifier().duplicate()-&gt;
        realization.Realizer().duplicate() ;
        create target::Class duplicate(source::Class): ... ;</pre>
<p>If a ' <code class="classname">Realization</code>' is contained in the '
          <code class="methodname">contents</code>' list of '
          <code class="varname">modelSource</code>', the '
          <code class="methodname">Realizer</code>' of the '
          <code class="classname">Realization</code>' will be added to the '
          <code class="varname">ownedElements</code>' list of the '
          <code class="varname">modelTarget</code>'. If you do not want to add in the case that the
          contained element is a 'Realization' you might change the extension to:</p>
<pre class="programlisting">Void duplicate(Realization realization):
        realization.Specifier().duplicate()-&gt;
        realization.Realizer().duplicate() -&gt; {} ;</pre>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10550"/>Recursion</h4>
</div>
</div>
</div>
<p>There is only one exception: For recursive extensions the return type
          cannot be inferred, therefore you need to specify it explicitly:</p>
<pre class="programlisting">String fullyQualifiedName(NamedElement n) : n.parent == null ?
        n.name : fullyQualifiedName(n.parent)+'::'+n.name ;</pre>
<p>Recursive extensions are non-deterministic in a static context,
          therefore, it is necessary to specify a return type.</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10559"/>Cached Extensions</h4>
</div>
</div>
</div>
<p>If you call an extension without side effects very often, you would like to
          cache the result for each set of parameters, in order improve the performance.
          You can just add the keyword '
          <code class="code">cached</code>' to the extension in order to achieve this:</p>
<pre class="programlisting">cached String getterName(NamedElement ele) :
        'get'+ele.name.firstUpper() ;</pre>
<p>The <code class="methodname">getterName</code> will be computed only once for
          each <code class="classname">NamedElement</code>.</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N1056B"/>Private Extensions</h4>
</div>
</div>
</div>
<p>By default all extensions are public, i.e. they are visible from outside the
          extension file. If you want to hide extensions you can add the keyword 'private'
          in front of them:</p>
<pre class="programlisting">private internalHelper(NamedElement ele) : //
        implementation.... ;</pre>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N10572"/>Java Extensions</h3>
</div>
</div>
</div>
<p>In some rare cases one does want to call a Java method from inside an expression.
        This can be done by providing a Java extension:</p>
<pre class="programlisting">Void myJavaExtension(String param) : JAVA
      my.Type.staticMethod(java.lang.String) ;</pre>
<p>The signature is the same as for any other extension. The implementation is
        redirected to a public static method in a Java class.</p>
<p>Its syntax is:</p>
<pre class="programlisting">JAVA fully.qualified.Type.staticMethod(my.ParamType1,
      my.ParamType2, ...) ;</pre>
<p>Note that you cannot use any imported namespaces. You have to specify the type,
        its method and the parameter types in a fully qualified way.</p>
<p>Example:</p>
<p>If you have defined the following Java extension:</p>
<pre class="programlisting">Void dump(String s) : JAVA my.Helper.dump(java.lang.String)
      ;</pre>
<p>and you have the following Java class:</p>
<pre class="programlisting">package my;
      public class Helper { public final static void dump(String aString) {
      System.out.println(aString); } }</pre>
<p>the expressions</p>
<pre class="programlisting">dump('Hello world!') 'Hello World'.dump()</pre>
<p>both result are invoking the Java method void dump(String aString)</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N10591"/>Create Extensions (Model Transformation)</h3>
</div>
</div>
</div>
<p>Since Version 4.1 the <span class="emphasis">
<em>Xtend</em>
</span> language supports
        additional support for model transformation. The new concept is called
        <span class="emphasis">
<em>create extension</em>
</span> and it is explained a bit more
        comprehensive as usual.</p>
<p>Elements contained in a model are usually referenced multiple times.
        Consider the following model structure:</p>
<pre class="programlisting"> P / \ C1 C2 \ / R </pre>
<p>A package P contains two classes C1 and C2. C1 contains a reference R of type C2 (P
        also references C2).</p>
<p>We could write the following extensions in order to transform an Ecore (EMF)
        model to our metamodel (Package, Class, Reference).</p>
<pre class="programlisting">toPackage(EPackage x) : let p = new Package :
      p.ownedMember.addAll(x.eClassifiers.toClass()) -&gt; p;
      toClass(EClass x) : let c = new Class :
      c.attributes.addAll(x.eReferences.toReference()) -&gt; c;
      toReference(EReference x) : let r = new Reference : r.setType(x.eType.toClass())
      -&gt; r; </pre>
<p>For an Ecore model with the above structure, the result would be:</p>
<pre class="programlisting"> P / \ C1 C2 | R - C2 </pre>
<p>What happened? The C2 class has been created 2 times (one time for the package
        containment and another time for the reference R that also refers to C2). We can
        solve the problem by adding the 'cached' keyword to the second extension:</p>
<pre class="programlisting">cached toClass(EClass x) : let c = new Class :
      c.attributes.addAll(c.eAttributes.toAttribute()) -&gt; c; </pre>
<p>The process goes like this:</p>
<div class="orderedlist">
<ol type="1">
<li>
<p>start create P</p>
<div class="orderedlist">
<ol type="a">
<li>
<p>start create C1 (contained in P)</p>
<div class="orderedlist">
<ol type="i">
<li>
<p>start create R (contained in C1)</p>
<div class="orderedlist">
<ol type="A">
<li>
<p>start create C2 (referenced from R)</p>
</li>
<li>
<p>end (result C2 is cached)</p>
</li>
</ol>
</div>
</li>
<li>
<p>end R</p>
</li>
</ol>
</div>
</li>
<li>
<p>end C1</p>
</li>
<li>
<p>start get cached C2 (contained in P)</p>
</li>
</ol>
</div>
</li>
<li>
<p>end P</p>
</li>
</ol>
</div>
<p>So this works very well. We will get the intended structure. But what about
        circular dependencies? For instance, C2 could contain a Reference R2 of type C1
        (bidirectional references):</p>
<p>The transformation would occur like this:</p>
<div class="orderedlist">
<ol type="1">
<li>
<p>start create P</p>
<div class="orderedlist">
<ol type="a">
<li>
<p>start create C1 (contained in P)</p>
<div class="orderedlist">
<ol type="i">
<li>
<p>start create R (contained in C1)</p>
<div class="orderedlist">
<ol type="A">
<li>
<p>start create C2 (referenced from R)</p>
<div class="orderedlist">
<ol type="I">
<li>
<p>start create R2 (contained in C2)</p>
<div class="orderedlist">
<ol type="1">
<li>
<p>start create C1 (referenced from R1)...
                                OOPS!</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
<p>C1 is already in creation and will not complete until the stack is reduced.
        Deadlock! The problem is that the cache caches the return value, but C1 was not
        returned so far, because it is still in construction. The solution: create
        extensions</p>
<p>The syntax is as follows:</p>
<pre class="programlisting">create Package toPackage(EPackage x) :
      this.classifiers.addAll(x.eClassifiers.toClass());
      create Class toClass(EClass x) :
      this.attributes.addAll(x.eReferences.toReference());
      create Reference toReference(EReference x) : this.setType(x.eType.toClass());
      </pre>
<p>This is not only a shorter syntax, but it also has the needed semantics: The
        created model element will be added to the cache before evaluating the body. The
        return value is always the reference to the created and maybe not completely
        initialized element.</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N105F3"/>Calling Extensions From Java</h3>
</div>
</div>
</div>
<p>The previous section showed how to implement Extensions in Java. This section
        shows how to call Extensions from Java.</p>
<pre class="programlisting">// setup XtendFacade f =
      XtendFacade.create("my::path::MyExtensionFile");
      // use f.call("sayHello",new Object[]{"World"}); </pre>
<p>The called extension file looks like this:</p>
<pre class="programlisting">sayHello(String s) : "Hello " + s;</pre>
<p>This example uses only features of the BuiltinMetaModel, in this case the "
        <code class="methodname">+</code>" feature from the StringTypeImpl.</p>
<p>Here is another example, that uses the JavaBeansMetaModel strategy. This
        strategy provides as additional feature: the access to properties using the
        getter and setter methods.</p>
<p>For more information about type systems, see the <span class="emphasis">
<em> <a class="xref" href="r10_expressions_language.html" title="Expressions">Expressions</a> </em>
</span> reference
        documentation.</p>
<p>We have one JavaBean-like metamodel class:</p>
<pre class="programlisting">package mypackage; public class MyBeanMetaClass { private String
      myProp; public String getMyProp() { return myProp; } public void setMyProp(String
      s) { myProp = s;} }</pre>
<p>in addition to the built-in metamodel type system, we register the
        JavaMetaModel with the JavaBeansStrategy for our facade. Now, we can use also this
        strategy in our extension:</p>
<pre class="programlisting">// setup facade
      XtendFacade f = XtendFacade.create("myext::JavaBeanExtension");
      // setup additional type system JavaMetaModel jmm = new JavaMetaModel("JavaMM",
      new JavaBeansStrategy());
      f.registerMetaModel(jmm);
      // use the facade MyBeanMetaClass jb = MyBeanMetaClass(); jb.setMyProp("test");
      f.call("readMyProp", new Object[]{jb}));</pre>
<p>The called extension file looks like this:</p>
<pre class="programlisting">import mypackage;
      readMyProp(MyBeanMetaClass jb) : jb.myProp ; </pre>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N10619"/>WorkflowComponent</h3>
</div>
</div>
</div>
<p>With the additional support for model transformation, it makes sense to
        invoke <span class="emphasis">
<em>Xtend</em>
</span> within a workflow. A typical workflow
        configuration of the <span class="emphasis">
<em>Xtend</em>
</span> component looks like
        this:</p>
<pre class="programlisting">
      
      &lt;component
      class="oaw.xtend.XtendComponent"&gt;
      &lt;metaModel class="oaw.type.emf.EmfMetaModel"&gt;
      &lt;metaModelFile value="metamodel1.ecore"/&gt;
      &lt;/metamodel&gt;
      &lt;metaModel class="oaw.type.emf.EmfMetaModel"&gt;
      &lt;metaModelFile value="metamodel2.ecore"/&gt;
      &lt;/metaModel&gt;
      &lt;invoke value="my::example::Trafo::transform(inputSlot)"/&gt;
      &lt;outputSlot value="transformedModel"/&gt;
      &lt;/component&gt; </pre>
<p>Note that you can mix and use any kinds of metamodels (not only EMF
        metamodels).</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N10629"/>Aspect-Oriented Programming in <span class="emphasis">
<em>Xtend</em>
</span> (since
        4.2)</h3>
</div>
</div>
</div>
<p>Using the workflow engine, it is now possible to package (e.g. zip) a written
        generator and deliver it as a kind of black box. If you want to use such a generator but
        need to change some things without modifying any code, you can make use of around
        advices that are supported by <span class="emphasis">
<em>Xtend</em>
</span>.</p>
<p>The following advice is weaved around every invocation of an extension whose
        name starts with 'my::generator::':</p>
<pre class="programlisting">around my::generator::*(*) : log('Invoking ' + ctx.name) -&gt;
      ctx.proceed() ; </pre>
<p>Around advices let you change behaviour in an non-invasive way (you do not need
        to touch the packaged extensions).</p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N1063A"/>Join Point and Point Cut Syntax</h4>
</div>
</div>
</div>
<p>Aspect orientaton is basically about weaving code into different points
          inside the call graph of a software module. Such points are called
          <span class="emphasis">
<em>join points</em>
</span>. In <span class="emphasis">
<em>Xtend</em>
</span> the join
          points are the extension invocations (Note that <span class="emphasis">
<em>Xpand</em>
</span>
          offers a similar feature, see the <span class="emphasis">
<em>Xpand</em>
</span>
          documentation).</p>
<p>One specifies on which join points the contributed code should be executed
          by specifying something like a 'query' on all available join points. Such a query
          is called a point cut.</p>
<pre class="programlisting">around [pointcut] : expression;</pre>
<p>A point cut consists of a fully qualified name and a list of parameter
          declarations.</p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="N10651"/>Extensions Name</h5>
</div>
</div>
</div>
<p>The extension name part of a point cut must match the fully qualified name
            of the definition of the join point. Such expressions are case sensitive. The
            asterisk character is used to specify wildcards. Some examples:</p>
<pre class="programlisting">my::Extension::definition // extensions with the specified
          name org::oaw::* //extensions prefixed with 'org::oaw::' *Operation* //
          extensions containing the word 'Operation' in it. * // all
          extensions</pre>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<p>Be careful when using wildcards, because you will get an endless
            recursion, in case you weave an extension, which is called inside the
            advice.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="N1065B"/>Parameter Types</h5>
</div>
</div>
</div>
<p>The parameters of the extensions that we want to add our advice to, can also
            be specified in the point cut. The rule is, that the type of the specified
            parameter must be the same or a supertype of the corresponding parameter type
            (the dynamic type at runtime) of the definition to be called.</p>
<p>Additionally, one can set the wildcard at the end of the parameter list, to
            specify that there might be none or more parameters of any kind.</p>
<p>Some examples:</p>
<pre class="programlisting">my::Templ::extension() // extension without parameters
          my::Templ::extension(String s) // extension with exactly one parameter of
          type String my::Templ::extension(String s,*) // templ def with one or more
          parameters, // where the first parameter is of type String
          my::Templ::extension(*) // templ def with any number of parameters
          </pre>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="N10666"/>Proceeding</h5>
</div>
</div>
</div>
<p>Inside an advice, you might want to call the underlying definition. This
            can be done using the implicit variable <code class="varname">ctx</code>, which is of
            the type <span class="type">xtend::AdviceContext</span> and provides an operation
            <code class="methodname">proceed()</code> which invokes the underlying
            definition with the original parameters (Note that you might have changed any
            mutable object in the advice before).</p>
<p>If you want to control what parameters are to be passed to the definition,
            you can use the operation <code class="methodname">proceed(List[Object]
            params)</code>. You should be aware, that in advices, no type checking
            is done.</p>
<p>Additionally, there are some inspection properties (like
            <code class="varname">name</code>, <code class="varname">paramTypes</code>, etc.)
            available.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10681"/>Workflow configuration</h4>
</div>
</div>
</div>
<p>To weave the defined advices into the different join points, you need to
          configure the <code class="classname">XtendComponent</code> with the qualified
          names of the Extension files containing the advices.</p>
<p>Example:</p>
<pre class="programlisting">
        
        &lt;component
        class="oaw.xtend.XtendComponent"&gt;
        &lt;metaModel class="oaw.type.emf.EmfMetaModel"&gt;
        &lt;metaModelFile value="metamodel1.ecore"/&gt;
        &lt;/metamodel&gt;
        &lt;metaModel class="oaw.type.emf.EmfMetaModel"&gt;
        &lt;metaModelFile value="metamodel2.ecore"/&gt;
        &lt;/metaModel&gt;
        
        &lt;invoke value="my::example::Trafo::transform(inputSlot)"/&gt;
        &lt;outputSlot value="transformedModel"/&gt;
        &lt;advices value="my::Advices,my::Advices2"/&gt;
        &lt;/component&gt; </pre>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xtend_example_introduction"/>Model-to-Model transformation with <span class="emphasis">
<em>Xtend</em>
</span>
          </h4>
</div>
</div>
</div>
<p>This example uses Eclipse EMF as the basis for model-to-model
          transformations. It builds on the <span class="emphasis">
<em>emfExample</em>
</span>
          documented elsewhere. Please read and install the
          <span class="emphasis">
<em>emfExample</em>
</span> first.</p>
<p>The idea in this example is to transform the data model introduced in the EMF
          example into itself. This might seem boring, but the example is in fact quite
          illustrative.</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xtend_example_workflow"/>Workflow</h4>
</div>
</div>
</div>
<p>By now, you should know the role and structure of workflow files. Therefore,
          the interesting aspect of the workflow file below is the <span class="emphasis">
<em>
          <code class="classname">XtendComponent</code> </em>
</span>.</p>
<pre class="programlisting">
        
        &lt;workflow&gt;
        &lt;property file="workflow.properties"/&gt; ...
        &lt;component class="oaw.xtend.XtendComponent"&gt;
        &lt;metaModel class="oaw.type.emf.EmfMetaModel"&gt;
        &lt;metaModelPackage value="data.DataPackage"/&gt;
        &lt;/metaModel&gt;
        &lt;invoke value="test::Trafo::duplicate(rootElement)"/&gt;
        &lt;outputSlot value="newModel"/&gt;
        &lt;/component&gt; ...
        &lt;/workflow&gt;</pre>
<p>As usual, we have to define the metamodel that should be used, and since we
          want to transform a data model into a data model, we need to specify only the
          <code class="classname">data.DataPackage</code> as the metamodel.</p>
<p>We then specify which function to invoke for the transformation. The
          statement <code class="classname">test::Trafo::duplicate(rootElement)</code>
          means to invoke:
          <div class="itemizedlist">
<ul type="disc">
<li> the <code class="classname">duplicate</code> function taking the
              contents of the <code class="classname">rootElement</code> slot as a parameter
              </li>
<li> the function can be found in the <code class="filename">Trafo.ext</code>
              file </li>
<li> and that in turn is in the classpath, in the
              <code class="classname">test</code> package </li>
</ul>
</div>
</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xtend_example_the_transformation"/>The Transformation</h4>
</div>
</div>
</div>
<p>The transformation, as mentioned above, can be found in the
          <code class="filename">Trafo.ext</code> file in the <code class="classname">test</code>
          package in the <code class="classname">src</code> folder. Let us walk through the
          file.</p>
<p>So, first we import the metamodel.</p>
<pre class="programlisting">import data;</pre>
<p>The next function is a so-called <code class="classname">create</code>
          extension. Create extensions, as a side effect when called, create an instance
          of the type given after the <code class="classname">create</code> keyword. In our
          case, the <code class="classname">duplicate</code> function creates an instance of
          <code class="classname">DataModel</code>. This newly created object can be referred
          to in the transformation by <code class="classname">this</code> (which is why
          <code class="classname">this</code> is specified behind the type). Since
          <code class="classname">this</code> can be omitted, we do not have to mention it
          explicitly in the transformation.</p>
<p>The function also takes an instance of <code class="classname">DataModel</code>
          as its only parameter. That object is referred to in the transformation as
          <code class="varname">s</code>. So, this function sets the name of the newly created
          <code class="classname">DataModel</code> to be the name of the original one, and then
          adds duplicates of all entities of the original one to the new one. To create the
          duplicates of the entities, the <code class="classname">duplicate()</code>
          operation is called for each <code class="classname">Entity</code>. This is the next
          function in the transformation.</p>
<pre class="programlisting">
        
        create DataModel this duplicate(DataModel
        s): entity.addAll(s.entity.duplicate()) -&gt;
        setName(s.name);</pre>
<p>The duplication function for entities is also a create extension. This
          time, it creates a new <code class="classname">Entity</code> for each old
          <code class="classname">Entity</code> passed in. Again, it copies the name and adds
          duplicates of the attributes and references to the new one.</p>
<pre class="programlisting">
        
        create Entity this duplicate(Entity old):
        attribute.addAll(old.attribute.duplicate()) -&gt;
        reference.addAll(old.reference.duplicate()) -&gt;
        setName(old.name);</pre>
<p>The function that copies the attribute is rather straight forward, but
          ...</p>
<pre class="programlisting">
        
        create Attribute this duplicate(Attribute
        old): setName(old.name) -&gt; setType(old.type);</pre>
<p>... the one for the references is more interesting. Note that a reference,
          while being owned by some <code class="classname">Entity</code>, also references
          another Entity as its target. So, how do you make sure you do not duplicate the
          target twice? <span class="emphasis">
<em>Xtend</em>
</span> provides explicit support for this
          kind of situation. <span class="emphasis">
<em>Create extensions are only executed once per
          tuple of parameters!</em>
</span> So if, for example, the
          <span class="emphasis">
<em>Entity</em>
</span> behind the target reference had already been
          duplicated by calling the <code class="methodname">duplicate</code> function with
          the respective parameter, the next time it will be called <span class="emphasis">
<em>the exact
          same object will be returned</em>
</span>. This is very useful for graph
          transformations.</p>
<pre class="programlisting">
        
        create EntityReference this
        duplicate(EntityReference old): setName( old.name ) -&gt; setTarget(
        old.target.duplicate() );</pre>
<p>For more information about the <span class="emphasis">
<em>Xtend</em>
</span> language
          please see the <span class="emphasis">
<em> <a class="xref" href="Xtend_language.html" title="Xtend">Xtend</a> </em>
</span>
          reference documentation.</p>
</div>
</div>
</body>
</html>
