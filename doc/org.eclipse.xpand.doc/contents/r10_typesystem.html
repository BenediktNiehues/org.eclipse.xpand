<html>
<head>
<title>Type System</title>
<link href="../book.css" rel="stylesheet" type="text/css"/>
<meta content="DocBook XSL Stylesheets V1.73.2" name="generator"/>
<link rel="start" href="index.html" title="Check / Xtend / Xpand Reference"/>
<link rel="up" href="index.html" title="Check / Xtend / Xpand Reference"/>
<link rel="prev" href="index.html" title="Check / Xtend / Xpand Reference"/>
<link rel="next" href="r10_expressions_language.html" title="Expressions"/>
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<p>The abstraction layer on API basis is called a type system. It provides access to
      built-in types and different registered metamodel implementations. These
      registered metamodel implementations offer access to the types they provide. The
      first part of this documentation describes the type system. The expression
      sub-language is described afterwards in the second part of this documentation. This
      differentiation is necessary because the type system and the expression language
      are two different things. The type system is a kind of reflection layer, that can be
      extended with metamodel implementations. The expression language defines a
      concrete syntax for executable expressions, using the type system.</p>
<p>The Java API described here is located in the
      <span class="package">org.openarchitectureware.type</span> package and is a part of the
      subproject
      <span class="package">core-expressions</span>.</p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="r10_typesystem_types"/>Types</h3>
</div>
</div>
</div>
<p>Every object (e.g. model elements, values, etc.) has a type. A type contains
        properties and operations. In addition it might inherit from other types
        (multiple inheritance).</p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_typesystem_typenames"/>Type Names</h4>
</div>
</div>
</div>
<p>Types have a simple Name (e.g. <code class="classname">String</code>) and an
          optional namespace used to distingish between two types with the same name (e.g.
          <code class="classname">my::metamodel</code>). The delimiter for name space
          fragments is a double colon " <code class="classname">::</code>". A fully qualified
          name looks like this:
          <pre class="programlisting">
          
          
          my::fully::qualified::MetaType</pre>
</p>
<p>The namespace and name used by a specific type is defined by the
          corresponding <code class="classname">MetaModel</code> implementation. The
          <code class="classname">EmfMetaModel</code>, for instance, maps
          <code class="classname">EPackages</code> to namespace and
          <code class="classname">EClassifiers</code> to names. Therefore, the name of the
          Ecore element <code class="classname">EClassifier</code> is called:</p>
<pre class="programlisting">ecore::EClassifier</pre>
<p>If you do not want to use namespaces (for whatever reason), you can always
          implement your own metamodel and map the names accordingly.</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_typesystem_collection_typenames"/>Collection Type Names</h4>
</div>
</div>
</div>
<p>The built-in type system also contains the following collection types:
          <code class="classname">Collection</code>, <code class="classname">List</code> and
          <code class="classname">Set</code>. Because the expressions language is statically
          type checked and we do not like casts and
          <code class="classname">ClassCastExceptions</code>, we introduced the concept of
          <span class="emphasis">
<em>parameterized types</em>
</span>. The type system does not support
          full featured generics, because we do not need them.</p>
<p>The syntax is:</p>
<pre class="programlisting">Collection[my::Type] List[my::Type] Set[my::Type]
        </pre>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_typesystem_features"/>Features</h4>
</div>
</div>
</div>
<p>Each type offers features. The type (resp. the metamodel) is responsible
          for mapping the features. There are three different kinds of features:
          <div class="itemizedlist">
<ul type="disc">
<li> Properties </li>
<li> Operations </li>
<li> Static properties </li>
</ul>
</div>
</p>
<p> <span class="emphasis">
<em>Properties</em>
</span> are straight forward: They have a name
          and a type. They can be invoked on instances of the corresponding type. The same is
          true for <span class="emphasis">
<em>Operations</em>
</span>. But in contrast to properties,
          they can have parameters. <span class="emphasis">
<em>Static properties</em>
</span> are the
          equivalent to enums or constants. They must be invoked statically and they do not
          have parameters.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="r10_builtintypes"/>Built-In Types</h3>
</div>
</div>
</div>
<p>As mentioned before, the expressions framework has several built-in types
        that define operations and properties. In the following, we will give a rough
        overview of the types and their features. We will not document all of the operations
        here, because the built-.in types will evolve over time and we want to derive the
        documentation from the implementation (model-driven, of course). For a complete
        reference, consult the generated API documentation ( <a class="ulink" href="http://www.openarchitectureware.org/api/built-ins/" target="_new">http://www.openarchitectureware.org/api/built-ins/</a>
        ).</p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_builtintypes_object"/> <code class="classname">Object</code>
        </h4>
</div>
</div>
</div>
<p> <code class="classname">Object</code> defines a couple of basic operations,
          like <code class="methodname">equals()</code>. Every type has to extend
          <code class="classname">Object</code>.</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_builtintypes_void"/> <code class="classname">Void</code>
        </h4>
</div>
</div>
</div>
<p>The <code class="classname">Void</code> type can be specified as the return type
          for operations, although it is not recommended, because whenever possible
          expressions should be free of side effects whenever possible.</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_builtintypes_simple"/>Simple types (Data types)</h4>
</div>
</div>
</div>
<p>The type system doesn't have a concept data type. Data types are just types.
          As in OCL, we support the following types: <code class="classname">String</code>,
          <code class="classname">Boolean</code>, <code class="classname">Integer</code>,
          <code class="classname">Real</code>.
          <div class="itemizedlist">
<ul type="disc">
<li>
<code class="classname">String</code> : A rich and convenient
              <code class="classname">String</code> library is especially important for code
              generation. The type system supports the '+' operator for concatenation,
              the usual <code class="classname">java.lang.String</code> operations (
              <code class="methodname">length()</code> , etc.) and some special operations
              (like <code class="methodname">toFirstUpper()</code> ,
              <code class="methodname">toFirstLower()</code> , regular expressions, etc.
              often needed in code generation templates). </li>
<li>
<code class="classname">Boolean</code> :
              <code class="classname">Boolean</code> offers the usual operators (Java
              syntax): &amp;&amp;, ||, !, etc. </li>
<li>
<code class="classname">Integer</code> and
              <code class="classname">Real</code> : <code class="classname">Integer</code> and
              <code class="classname">Real</code> offer the usual compare operators
              (&lt;,&gt;,&lt;=,&gt;=) and simple arithmetics (+,-,*,/). Note that
              <span class="emphasis">
<em> <code class="classname">Integer</code> extends
              <code class="classname">Real</code>
</em>
</span> ! </li>
</ul>
</div>
</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_builtintypes_collections"/>Collection types</h4>
</div>
</div>
</div>
<p>The type system has three different Collection types.
          <code class="classname">Collection</code> is the base type, it provides several
          operations known from <code class="classname">java.util.Collection</code>. The
          other two types ( <code class="classname">List</code>, <code class="classname">Set</code>
          ) correspond to their
          <span class="package">java.util</span> equivalents, too.</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_builtintypes_typesystem_types"/>Type system types</h4>
</div>
</div>
</div>
<p>The type system describes itself, hence, there are types for the different
          concepts. These types are needed for reflective programming. To avoid
          confusion with metatypes with the same name (it is not unusual to have a metatype
          called <code class="classname">Operation</code>, for instance) we have prefixed all
          of the types with the namespace <code class="classname">oaw</code>. We have:</p>
<div class="itemizedlist">
<ul type="disc">
<li>
<code class="classname">oaw::Type</code>
</li>
<li>
<code class="classname">oaw::Feature</code>
</li>
<li>
<code class="classname">oaw::Property</code>
</li>
<li>
<code class="classname">oaw::StaticProperty</code>
</li>
<li>
<code class="classname">oaw::Operation</code>
</li>
</ul>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="r10_metamodel_implementations"/>Metamodel Implementations (also known as Meta-Metamodels)</h3>
</div>
</div>
</div>
<p>By default, the type system only knows the built-in types. In order to register
        your own metatypes (e.g. <code class="classname">Entity</code> or
        <code class="classname">State</code>), you need to register a respective metamodel
        implementation with the type system. Within a metamodel implementation the oAW
        type system elements (Type, Property, Operation) are mapped to an arbitrary other
        type system (Java reflections, Ecore or XML Schema).</p>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_metamodel_example_java"/>Example JavaMetaModel</h4>
</div>
</div>
</div>
<p>For instance, if you want to have the following JavaBean act as a metatype
          (i.e. your model contains instances of the type):</p>
<pre class="programlisting">
        
        public class Attribute { private String name;
        private String type; public String getName() { return name; } public void
        setName(String name) { this.name = name; } public String getType() { return type; }
        public void setType(String type) { this.type = type; } } </pre>
<p>You need to use the <code class="classname">JavaMetaModel</code>
          implementation which uses the ordinary Java reflection layer in order to map
          access to the model.</p>
<p>So, if you have the following expression in e.g.
          <span class="emphasis">
<em>Xpand</em>
</span>:</p>
<pre class="programlisting">myattr.name.toFirstUpper()</pre>
<p>and <code class="varname">myattr</code> is the name of a local variable pointing to
          an instance of <code class="classname">Attribute</code>. The oAW type system asks the
          metamodel implementations, if they 'know' a type for the instance of Attribute.
          If you have the <code class="classname">JavaMetaModel</code> registered it will
          return an <code class="classname">oaw::Type</code> which maps to the underlying Java
          class. When the type is asked if it knows a property ' <code class="varname">name</code>',
          it will inspect the Java class using the Java reflection API.</p>
<p>The JavaMetaModel implementation shipped with oAW can be configured with a
          strategy [GOF95-Pattern] in order to control or change the mapping. For
          instance, the JavaBeansStrategy maps getter and setter methods to simple
          properties, so we would use this strategy for the example above.</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_metamodel_contributors"/>Eclipse IDE MetaModelContributors</h4>
</div>
</div>
</div>
<p>You should know that for each <code class="classname">Metamodel</code>
          implementation you use at runtime, you need to have a so called
          <code class="classname">MetamodelContributor</code> extension for the plugins to
          work with. If you just use one of the standard metamodel implementations (EMF,
          UML2 or Java) you don't have to worry about it, since oAW is shipped with
          respective MetamodelContributors (see the corresponding docs for details).
          If you need to implement your own
          <code class="classname">MetamodelContributor</code> you should have a look at the
          Eclipse plug-in reference doc.</p>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="r10_metamodel_workflow"/>Configuring Metamodel implementations with the workflow</h4>
</div>
</div>
</div>
<p>You need to configure your oAW language components with the respective
          metamodel implementations.</p>
<p>A possible configuration of the <code class="classname">Xpand2</code>
          generator component looks like this:</p>
<pre class="programlisting">
        
        &lt;component
        class="oaw.xpand2.Generator"&gt;
        &lt;metaModel class="oaw.type.emf.EmfMetaModel"&gt;
        &lt;metaModelPackage value="my.generated.MetaModel1Package"/&gt;
        &lt;/metaModel&gt;
        &lt;metaModel class="oaw.type.emf.EmfMetaModel"&gt;
        &lt;metaModelFile value="my/java/package/metamodel2.ecore"/&gt;
        &lt;/metaModel&gt; ...
        &lt;/component&gt; </pre>
<p>In this example the <code class="classname">EmfMetaModel</code>
          implementation is configured two times. This means that we want to use two
          metamodels at the same time, both based on EMF. The metaModelPackage property is
          a property that is specific to the <code class="classname">EmfMetaModel</code>
          (located in the <code class="filename">core.emftools</code> project). It points to
          the generated <code class="classname">EPackages</code> interface. The second meta
          model is configured using the Ecore file. You do no need to have a generated Ecore
          model for oAW in order to work. The <code class="classname">EmfMetaModel</code> works
          with dynamic EMF models just as it works with generated EMF models.</p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="r10_using_different_metamodels"/>Using different Metamodel implementations (also known as
        Meta-Metamodels)</h3>
</div>
</div>
</div>
<p>With oAW you can work on different kinds of Model representations at the same
        time in a transparent manner. One can work with EMF models, XML DOM models, and
        simple JavaBeans in the same Xpand-Template. You just need to configure the
        respective MetaModel implementations.</p>
<p>If you want to do so you need to know how the type lookup works. Let us assume that
        we have an EMF metamodel and a model based on some Java classes. Then the following
        would be a possible configuration:</p>
<pre class="programlisting">
      
      &lt;component
      class="oaw.xpand2.Generator"&gt;
      &lt;metaModel class="oaw.type.impl.java.JavaMetaModel"/&gt;
      &lt;metaModel class="oaw.type.emf.EmfMetaModel"&gt;
      &lt;metaModelFile value="my/java/package/metamodel.ecore"/&gt;
      &lt;/metaModel&gt;
      ...
      &lt;/component&gt; </pre>
<p>When the oAW runtime needs to access a property of a given object, it asks the
        metamodels in the configured order. Let us assume that our model element is an
        instance of the Java type
        <code class="classname">org.eclipse.emf.ecore.EObject</code> and it is a dynamic
        instance of an EMF EClass <code class="classname">MyType</code>.</p>
<p>We have <span class="emphasis">
<em>three</em>
</span> Metamodels:
        <div class="orderedlist">
<ol type="1">
<li> Built-Ins (always the first one) </li>
<li> JavaMetaModel </li>
<li> EMFMetaModel &#8211; metamodel.ecore </li>
</ol>
</div>
</p>
<p>The first one will return the type <code class="classname">Object</code> (not
        <code class="classname">java.lang.Object</code> but
        <code class="classname">Object</code> of oAW). At this point the type
        <code class="classname">Object</code> best fits the request, so it will act as the
        desired type.</p>
<p>The second metamodel returns an oAW type called
        <code class="classname">oaw::eclipse::emf::ecore::EObject</code> The type system
        will check if the returned type is a specialization of the current 'best-fit' type (
        <code class="classname">Object</code>). It is, because it extends
        <code class="classname">Object</code> (Every metatype has to extend
        <code class="classname">Object</code>). At this time the type system assumes
        <code class="classname">oaw::eclipse::emf::ecore::EObject</code> to be the desired
        type.</p>
<p>The third metamodel will return
        <code class="classname">metamodel::MyType</code> which is the desired type. But
        unfortunately it doesn't extend
        <code class="classname">org::eclipse::emf::ecore::EObject</code> as it has nothing
        to do with those Java types. Instead it extends
        <code class="classname">emf::EObject</code> which extends
        <code class="classname">Object</code>.</p>
<p>We need to swap the configuration of the two metamodels to get the desired
        type.</p>
<pre class="programlisting">
      
      &lt;component
      class="oaw.xpand2.Generator"&gt;
      &lt;metaModel class="oaw.type.emf.EmfMetaModel"&gt;
      &lt;metaModelFile value="my/java/package/metamodel.ecore"/&gt;
      &lt;/metaModel&gt;
      &lt;metaModel class="oaw.type.impl.java.JavaMetaModel"/&gt;
      ...
      &lt;/component&gt;</pre>
</div>
</body>
</html>
