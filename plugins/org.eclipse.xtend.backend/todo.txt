todo
----
registry of handlers for different kinds of resources (including classes and byte code (?)); classes need way to express their fdc!!! --> rethink fdc concept?
make the concept of the "XyzRegistry" explicit, common abstraction --> interoperability of languages
configuration of backend type system - parameters to the backend?
globalVars rauswerfen? --> ContributionStateContext?

JavaBeansType: Interfaces als Supertypen
UML type system
logNullDeRef: log call stack including call parameters - runtime flag to log "verbosely"?
AOP
Profiler

Check: SourcePos-Infos in Fehlern, Exceptions in ExpressionBase ordentlich gewrappt

static properties; enums

kommentieren

Marker-Interface / Annotation "FunctionDefs" o.ä. --> generische Unterscheidung für Java-Importer, ob Klasse
  als Bean oder als "Funktionen-Container"

testen, insbes. syslib

DefinitionType in FunctionType mergen

dead code elimination?

isInstance

Buddy Policy für syslib und backend

syslib-Funktion: allFunctions (List<Type>) --> auch Funktionen ohne Parameter zur Laufzeit 
  finden (oder built-in? --> syslib-Aufruf verlässt den Scope)
Function-Match (z.B. &myFunc (String, Foo) --> spät binden! --> dynamisch durchgereichter Kram
  wird gematcht
Currying
Map als Builtin-Typ
Properties über getter/setter abbilden (z.B. im mm keine property mehr)?
Eigene Properties definieren (d.h. generische Map dafür an jedem Objekt)?
"final" (auch als Hint für Optimierung --> wird nicht durch dynamische Exytensions
  erweitert --> Tail Recursion geht nur dort)
Initialisierung der Functions mit FunctionDefContext: Nicht zwingend eager
  in voller Tiefe, sondern lazy beim ersten Einstieg in eine neue CompilationUnit
zusätzlich zu statisch unterschiedenem this / Collection-Sonderfall außerdem
  den generischen Fall --> aber nur dann (Ref-Typ "Object"), wenn es statisch
  nicht entscheidbar ist. --> volle Rückwärtskompatibilität
globale Type-Registry für alle zurückgegebenen Objekte --> nach beliebigem Rumreichen
  kann man an ihnen zumindest die eingebauten Operations aufrufen, auf ihre Properties
  zugreifen

Konzept für stufenweises Überschreiben - syslib --> built-in operation --> Extension (oder so)

Debugger: ein Source-Primitive kann aus mehreren Runtime-Primitives bestehen - in der RT 
	markieren, wo neuer Source-Primitive beginnt? Oder einfach Mapping in Rückrichtung 
	und vergleichen?
tail recursion
replace/add von Extensions im dynamischen Scope

equals auf Type-Implementierungen


Unterstützung
-------------
UML und EMF testen


Decisions
---------
Overwriting / hiding of functions is only posible for functions without guards (to avoid 
  the necessity of comparing guards for equality)
IteratorType is now handled via the Java type system
Only one global type system to avoid ambiguities when objects are passed from one compilation unit to another


Ideen für die Zukunft
---------------------
"async" -Keyword --> Ausnutzung von Multicore???


statisch behandeln
----------------
hasThis etc. im FunctionDefContext statisch handeln?
"this"-Mehrdeutigkeit (welche Reihenfolge?)
Collection-Resolution-Mehrdeutigkeit


done
----
Interface ExecutionContextAware für Java-Extensions
cached
PolymorphicResolver
int / long: gnädig bei Java-Extensions
double / float: gnädig bei Java-Extensions
Array / List
optimierter String --> an Schnittstellen ggf. konvertieren
optimierter String --> hierarchische Dirty-Propagation nach oben
JavaBeansTypesystem
Konzept für FunctionType - braucht der Parametertypen!?
metaType etc.
EMF-Typesystem
setExecutionContext bei ExecutionContextAware nicht als exportierte Funktion behandeln
toString() überschreibbar, trotz lazy evaluation
Operators: implies, <, <=, ==, !=, >=, >, !, unary -, 
potential bug - EfficientLazyString is mutable || return value from cached function --> 
  flag "isImmutable" in EfficientLazyString; static method "concat" insetad of "append" to treat this transparently

