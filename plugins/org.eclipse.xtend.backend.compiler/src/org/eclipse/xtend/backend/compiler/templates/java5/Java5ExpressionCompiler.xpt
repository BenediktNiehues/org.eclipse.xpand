«IMPORT org::eclipse::xtend::backend::aop»
«IMPORT org::eclipse::xtend::backend::common»
«IMPORT org::eclipse::xtend::backend::expr»
«IMPORT org::eclipse::xtend::backend::functions»
«IMPORT org::eclipse::xtend::middleend::plugins»
«IMPORT org::eclipse::xtend::backend::util»
«IMPORT org::eclipse::xtend::backend::compiler»
«IMPORT org::eclipse::xtend::middleend::javaannotations::internal»

«EXTENSION org::eclipse::xtend::backend::compiler::templates::expressions»
«EXTENSION org::eclipse::xtend::backend::compiler::templates::functions»
«EXTENSION org::eclipse::xtend::backend::compiler::templates::names»
«EXTENSION org::eclipse::xtend::backend::compiler::templates::types»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR Object»
«ENDDEFINE»
«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR ExpressionBase»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR AndExpression»
	«LET getNextVarIdx() AS varIdx-»
		«EXPAND compileExpression (getVarName(left, "leftVarName", "_"+varIdx), "Boolean", resource) FOR left-»
		«EXPAND compileExpression (getVarName(right, "rightVarName", "_"+varIdx), "Boolean", resource) FOR right-»
		if («getVarName(left, "leftVarName", "_"+varIdx)» && «getVarName(right, "rightVarName", "_"+varIdx)»)
			boolean «resultVarName» = true;
		else 
			boolean «resultVarName» = false;
	«ENDLET-»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR ConcatExpression»
	«LET getNextVarIdx() AS varIdx-»
        List<Object> «resultVarName»_Parts = new ArrayList<Object> («parts.size»);
		«FOREACH parts AS p ITERATOR it-»
			«EXPAND compileExpression (p.getVarName (resultVarName, "_ConcatPart_" +it.counter1), "Object", resource) FOR p-»
			«resultVarName»_Parts.add («p.getVarName (resultVarName, "_ConcatPart_" +it.counter1)»);
		«ENDFOREACH-»
		EfficientLazyString «resultVarName» = Concatenator.append (_ctx, «resultVarName»_Parts);
	«ENDLET-»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR CreateCachedExpression-»
	«LET getNextVarIdx() AS varIdx-»
        final List<Object> params_«varIdx» = new ArrayList<Object>();
		«FOREACH paramExpr AS p ITERATOR it-»
			«EXPAND compileExpression (getVarName(p, "createParamVarName", "_"+ varIdx + "_" +it.counter1), "Object", resource) FOREACH paramExpr-»
			params_«varIdx».add ( createParamVarName_«varIdx»_«it.counter0»);
		«ENDFOREACH-»
        «resultType.getResultType()» «resultVarName» = _ctx.getCreationCache().createRaw (_ctx.getTypesystem ().findType ("«type.uniqueRepresentation»"), params_«varIdx»);
	«ENDLET-»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR CreateUncachedExpression»
		«resultType.getResultType()» «resultVarName» = _ctx.getTypesystem ().findType ("«type.uniqueRepresentation»").create();
«ENDDEFINE»

«REM»
TODO Get the function somehow
«ENDREM»
«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR CurryingExpression-»
	«LET getNextVarIdx() AS varIdx-»
		«LET getNamedFunction (function) AS f»
		Function function_«varIdx» = _ctx.getFunctionDefContext().getMatch («f.name.getQualifiedNameBuilder()», «f.function.getFunctionParameterTypes()»);
		«ENDLET-»
		List<Object> boundParamVarName_«varIdx» = new ArrayList<Object>();
		«FOREACH boundParams.typeSelect(ExpressionBase) AS p ITERATOR it-»
			«EXPAND compileExpression(getVarName(p, "boundParamVarName", "_" + varIdx + "_" + it.counter1), "Object", resource) FOR p-»
			boundParamsVarName.add(boundParamVarName_«varIdx»_«it.counter1»);
		«ENDFOREACH-»
		Function «resultVarName» = new CurriedFunction (function_«varIdx», boundParamVarName_«varIdx», _ctx); 
	«ENDLET-»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR DeferredEvalExpression-»
	«LET getNextVarIdx() AS varIdx-»
		«resultType.getResultType()» «resultVarName» = new FutureResultHolder (new AbstractFunction () {
			public Object invoke (ExecutionContext _ctx, Object[] params) {
				«EXPAND compileExpression (getVarName(innerExpr, "deferredExprVarName", "_"+varIdx), "Object", resource) FOR innerExpr-»
				return «getVarName(innerExpr, "deferredExprVarName", "_"+varIdx)»;
			}
		});
	«ENDLET-»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR HidingLocalVarDefExpression-»
	«LET getNextVarIdx() AS varIdx-»
        final Object oldValue_«varIdx» = _ctx.getLocalVarContext().getLocalVars().get(«localVarName»);
        «EXPAND compileExpression (getVarName (defExpression, "defExprResult", "_" + varIdx), "Object", resource) FOR defExpression-» 
        _ctx.getLocalVarContext().getLocalVars().put («localVarName», «getVarName (defExpression, "defExprResult", "_" + varIdx)»);

        if (_ctx.isLogStacktrace())
            _ctx.getStacktrace().add (new StacktraceEntry («pos.buildSourcePos()», _ctx));

        try {
			«EXPAND compileExpression (resultVarName, "Object", resource) FOR innerExpression-»
        }
        finally {
            _ctx.getStacktrace ().remove (_ctx.getStacktrace().size() - 1);
            _ctx.getLocalVarContext().getLocalVars().put(«localVarName», oldValue_«varIdx»);
        }
	«ENDLET-»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR IfExpression-»
	«LET getNextVarIdx() AS varIdx»
		boolean «getVarName (condition, "condExprVarName", "_" + varIdx)» = false;
		«EXPAND compileExpression (getVarName (condition, "condExprVarName", "_" + varIdx), "Boolean", resource) FOR condition-»
		if (condExprVarName_«varIdx») {
		«EXPAND compileExpression (resultVarName, resultType, resource) FOR ifPart-»
		} else {
		«EXPAND compileExpression (resultVarName, resultType, resource) FOR elsePart-»
		}
	«ENDLET»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR InitClosureExpression-»
	«LET getNextVarIdx() AS varIdx-»
		List<String> paramNames_«varIdx» = Arrays.asList («IF !paramNames.isEmpty»"«FOREACH paramNames AS pName SEPARATOR ","»«pName»«ENDFOREACH»"«ENDIF»);
		List<BackendType> paramTypes_«varIdx» = new ArrayList<BackendType>();
		«FOREACH paramTypes.typeSelect(BackendType) AS pt-»
			paramTypes_«varIdx».add (_ctx.getTypesystem ().findType ("«pt.uniqueRepresentation»"));
		«ENDFOREACH-»
		Function «resultVarName» = new AbstractClosure (_ctx.getLocalVarContext(), _ctx.getFunctionDefContext(), paramNames_«varIdx», paramTypes_«varIdx») {
			protected Object apply (ExecutionContext _ctx) {
				«EXPAND compileExpression (getVarName (defExpression, "defExpr", "_" +varIdx), "Object", resource) FOR defExpression-»
				return «getVarName (defExpression, "defExpr", "_" +varIdx)»;
			}
		};
	«ENDLET-»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR InvocationOnCollectionExpression-»
	«LET getNextVarIdx() AS varIdx-»
        «EXPAND compileExpression (getVarName(collection, "coll", "_" +varIdx), "Collection", resource) FOR collection-»
        «IF params.size > 0 && LocalVarEvalExpression.isInstance(params.first())-»
        	«IF (((LocalVarEvalExpression)params.first()).localVarName == "this")-»
        		boolean firstParamIsThis_«varIdx» = true;
        	«ELSE-»
		        boolean firstParamIsThis_«varIdx» = false;	
        	«ENDIF-»
        «ELSE-»
	        boolean firstParamIsThis_«varIdx» = false;
        «ENDIF-»
	    final List<Object> params_«varIdx» = new ArrayList<Object>();
	    params_«varIdx».add (null); //placeholder
		«FOREACH params AS e-»
			«EXPAND compileExpression (getVarName (e, "param", "_"+varIdx), "Object", resource) FOR e-»
			params_«varIdx».add («getVarName (e, "param", "_"+varIdx)»);        	
		«ENDFOREACH-»
		«resultType.getResultType()» «resultVarName» = «IF resultType.getResultType() != "Object"»(«resultType.getResultType()») «ENDIF»Invoker.invokeOnCollection(«functionName.getQualifiedNameBuilder()», coll_«varIdx», params_«varIdx», _ctx, firstParamIsThis_«varIdx», SourcePos);
	«ENDLET-»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR InvocationOnObjectExpression-»
	«LET getNextVarIdx() AS varIdx-»
        «REM»MATCH THE TWO OF THEM«ENDREM» 
        final List<Object> params_«varIdx» = new ArrayList<Object> ();
        «IF params.size > 0 && LocalVarEvalExpression.isInstance (params.first())-»
        	«IF (((LocalVarEvalExpression) params.first()).localVarName == "this")-»
        		boolean firstParamIsThis_«varIdx» = true;
        	«ELSE-»
		        boolean firstParamIsThis_«varIdx» = false;	
        	«ENDIF-»
        «ELSE-»
	        boolean firstParamIsThis_«varIdx» = false;
        «ENDIF-»
        «FOREACH params AS e ITERATOR it-»
        	«EXPAND compileExpression (getVarName (e, "paramExprRes", "_"+varIdx+"_"+it.counter1), "Object", resource) FOR e-»
        	params_«varIdx».add («getVarName (e, "paramExprRes", "_"+varIdx+"_"+it.counter1)»);
        «ENDFOREACH-»
        «IF nullIfFirstParamIsNull && params.size > 0-»
		«resultType.getResultType()» «resultVarName» = «IF resultType.getResultType() != "Object"»(«resultType.getResultType()») «ENDIF»Invoker.invokeOnObjectNullChecked(«functionName.getQualifiedNameBuilder()», params_«varIdx», _ctx, firstParamIsThis_«varIdx», «pos.buildSourcePos()»);
        «ELSE-»
		«resultType.getResultType()» «resultVarName» = «IF resultType.getResultType() != "Object"»(«resultType.getResultType()») «ENDIF»Invoker.invokeOnObject(«functionName.getQualifiedNameBuilder()», params_«varIdx», _ctx, firstParamIsThis_«varIdx»);
        «ENDIF-»
	«ENDLET-»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR InvocationOnWhateverExpression-»
	«LET getNextVarIdx() AS varIdx-»
        «IF params.size > 0 && LocalVarEvalExpression.isInstance(params.first())»
        	«IF (((LocalVarEvalExpression) params.first()).localVarName == "this")-»
        		boolean firstParamIsThis_«varIdx» = true;
        	«ELSE-»
		        boolean firstParamIsThis_«varIdx» = false;	
        	«ENDIF-»
        «ELSE»
	        boolean firstParamIsThis_«varIdx» = false;
        «ENDIF»
        final List<Object> params_«varIdx» = new ArrayList<Object> ();
        «FOREACH params AS e ITERATOR it-»
        	«EXPAND compileExpression (getVarName (e, "paramExprRes", "_"+varIdx+"_"+it.counter1), "Object", resource) FOR e-»
        	params_«varIdx».add («getVarName (e, "paramExprRes", "_"+varIdx+"_"+it.counter1)»);
        «ENDFOREACH-»
        «IF nullIfFirstParamIsNull && params.size > 0-»
 		«resultType.getResultType()» «resultVarName» = «IF resultType.getResultType() != "Object"»(«resultType.getResultType()») «ENDIF»Invoker.invokeOnWhatEverNullChecked(«functionName.getQualifiedNameBuilder()», params_«varIdx», _ctx, firstParamIsThis_«varIdx», «pos.buildSourcePos()»);
        «ELSE-»
 		«resultType.getResultType()» «resultVarName» = «IF resultType.getResultType() != "Object"»(«resultType.getResultType()») «ENDIF»Invoker.invokeOnWhatEver(«functionName.getQualifiedNameBuilder()», params_«varIdx», _ctx, firstParamIsThis_«varIdx»);
        «ENDIF-»
	«ENDLET-»
«ENDDEFINE»


«DEFINE compileExpression (String resultVarName, String resultType, ParsedResource resource) FOR ListLiteralExpression-»
	«LET getNextVarIdx() AS varIdx-»
        final List<Object> «resultVarName» = new ArrayList<Object>();
        «FOREACH innerExpression AS e ITERATOR it-»
        	«EXPAND compileExpression (getVarName (e, "exprRes", "_"+ varIdx + "_" + it.counter1), "Object", resource) FOR e-»
        	«resultVarName».add (exprRes_«varIdx»);
        «ENDFOREACH-»
	«ENDLET-»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR LiteralExpression-»
		«resultType.getResultType()» «resultVarName» = «this.toJavaLiteral()»;
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR LocalVarEvalExpression-»
		«resultType.getResultType()» «resultVarName» = _ctx.getLocalVarContext().getLocalVars().get ("«localVarName»");
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR MethodInvocationExpression-»
	«LET getNextVarIdx() AS varIdx-»
        «IF params.size > 0 && LocalVarEvalExpression.isInstance(params.first())»
        	«IF (((LocalVarEvalExpression) params.first()).localVarName == "this")-»
        		boolean firstParamIsThis_«varIdx» = true;
        	«ELSE-»
		        boolean firstParamIsThis_«varIdx» = false;	
        	«ENDIF-»
        «ELSE»
	        boolean firstParamIsThis_«varIdx» = false;
        «ENDIF»
		Class cls = «method.declaringClass.name».class;
		«IF method.parameterTypes.size > 0-»
			Method mtd = cls.getMethod(«method.name», «FOREACH method.parameterTypes AS pt SEPARATOR ", "»«pt.name»«ENDFOREACH»);
		«ELSE-»
			Method mtd = cls.getMethod(«method.name»);
		«ENDIF-»
		List<Object> «method.name»_params_«varIdx» = new ArrayList<Object>();
		«FOREACH params.typeSelect(ExpressionBase) AS p ITERATOR it-»
			«EXPAND compileExpression (getVarName (p, "paramVarName", "_" + varIdx + "_" +it.counter1), "Object", resource) FOR p-»
			«method.name»_params_«varIdx».add(«getVarName (p, "paramVarName", "_" + varIdx + "_" +it.counter1)»);
		«ENDFOREACH-»
		«resultType.getResultType()» «resultVarName» = Invoker.invokeMethod (mtd, «method.name»_params_«varIdx», «static», _ctx, «nullIfFirstParamIsNull», firstParamIsThis_«varIdx», «pos.buildSourcePos()»)
	«ENDLET-»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR NewLocalVarDefExpression-»
	«LET getNextVarIdx() AS varIdx-»
		«EXPAND compileExpression (getVarName(defExpression, "varDefExpr", "_" + varIdx), "Object", resource) FOR defExpression-»
        _ctx.getLocalVarContext().getLocalVars().put («localVarName», «getVarName(defExpression, "varDefExpr", "_" + varIdx)»);
        if (_ctx.isLogStacktrace())
            _ctx.getStacktrace().add (new StacktraceEntry («pos.buildSourcePos()», _ctx));
        try {
        	«EXPAND compileExpression (getVarName (innerExpression, "newLocalVarDefExpr", "_inner_"+varIdx), "Object", resource ) FOR innerExpression-»
        	«resultType.getResultType()» «resultVarName» = «getVarName (innerExpression, "newLocalVarDefExpr", "_inner_"+varIdx)»;
        }
        finally {
            if (_ctx.isLogStacktrace())
                _ctx.getStacktrace ().remove (_ctx.getStacktrace().size() - 1);
            _ctx.getLocalVarContext ().getLocalVars ().remove («localVarName»);
        }
	«ENDLET-»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR OrExpression-»
	«LET getNextVarIdx() AS varIdx-»
		«EXPAND compileExpression (getVarName (left, "leftVarName", "_" +varIdx), "Boolean", resource) FOR left-»
		«EXPAND compileExpression (getVarName (right, "rightVarName", "_" +varIdx), "Boolean", resource) FOR right-»
		if (leftVarName_«varIdx» || rightVarName_«varIdx»)
			Boolean «resultVarName» = true;
		else
			Boolean «resultVarName» = false;
	«ENDLET-»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR PropertyOnCollectionExpression-»
	«LET getNextVarIdx() AS varIdx-»
        «EXPAND compileExpression (getVarName (innerExpression, "coll", "_"+varIdx), "Object", resource ) FOR innerExpression-»
        «resultType.getResultType()» «resultVarName» = PropertyAccessor.propertyOnCollection(«getVarName (innerExpression, "coll", "_"+varIdx)», "«propertyName»", _ctx, «pos.buildSourcePos()»);
	«ENDLET-»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR PropertyOnObjectExpression-»
	«LET getNextVarIdx() AS varIdx-»
		«EXPAND compileExpression (innerExpression.getVarName ("innerPropertyOnObjectExpr", "_" + varIdx), "Object", resource) FOR innerExpression-»
       	«resultType.getResultType()» «resultVarName» = PropertyAccessor.propertyOnObject(«innerExpression.getVarName ("innerPropertyOnObjectExpr", "_" + varIdx)», "«propertyName»", _ctx, «pos.buildSourcePos()»);
	«ENDLET-»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR PropertyOnWhateverExpression-»
	«LET getNextVarIdx() AS varIdx-»
		«EXPAND compileExpression (innerExpression.getVarName("innerPropertyExpr", "_" + varIdx),"Object", resource) FOR innerExpression-»
        «resultType.getResultType()» «resultVarName» = PropertyAccessor.propertyOnWhatever(«innerExpression.getVarName("innerPropertyExpr", "_" + varIdx)», "«propertyName»", _ctx, «pos.buildSourcePos()»);
	«ENDLET-»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR RegisterAdviceExpression-»
	«LET getNextVarIdx() AS varIdx»
		«EXPAND compileAdvice (advice.getVarName ("advVarName", "_" +varIdx), resource) FOR advice»
        final AdviceContext oldContext_«varIdx» = _ctx.getAdviceContext();
        _ctx.setAdviceContext (_ctx.getAdviceContext ().copyWithAdvice (_advice));
        try {
			«EXPAND compileExpression (innerExpression.getVarName("innerRegisterAdviceExpr", "_" + varIdx), "Object", resource) FOR innerExpression»
            «resultType.getResultType()» «resultVarName» = «innerExpression.getVarName("innerRegisterAdviceExpr", "_" + varIdx)»;
        }
        finally {
            _ctx.setAdviceContext (oldContext_«varIdx»);
        }
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR SequenceExpression»
	«LET getNextVarIdx() AS varIdx»
		«IF inner.size > 0 -» 
	        «FOREACH inner AS e ITERATOR it-»
	        	«IF it.firstIteration-»
	        		«EXPAND compileExpression (resultVarName, resultType, resource) FOR e»
	        	«ELSE-»
	        		«EXPAND compileExpression (resultVarName, null, resource) FOR e»
	        	«ENDIF-»
	        «ENDFOREACH»
        «ELSE-»
        	«IF resultType == "boolean"-»
        		boolean «resultVarName» = false;
        	«ELSEIF resultType == "Boolean" -»
        		Boolean «resultVarName» = Boolean.FALSE;
        	«ELSE -»
        		«resultType.getResultType()» «resultVarName» = null; 
        	«ENDIF-»
        «ENDIF-»
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR SetPropertyExpression»
	«LET getNextVarIdx() AS varIdx»
		«EXPAND compileExpression (innerExpression. getVarName("innerPropertyExpr", "_" + varIdx), "Object", resource) FOR innerExpression»
        if (innerSetPropertyExpr_«varIdx» == null) {
            _ctx.logNullDeRef («pos.buildSourcePos()»);
            «resultType.getResultType()» «resultVarName» =  null;
        } else {
	        final BackendType t_«varIdx» = _ctx.getTypesystem().findType(o);
			«EXPAND compileExpression (valueExpr.getVarName ("value", "_" + varIdx), "Object", resource) FOR valueExpr»
	        t_«varIdx».setProperty (_ctx, innerSetPropertyExpr_«varIdx», "«propertyName»", value_«varIdx»);
	        «resultType.getResultType()» «resultVarName» = innerSetPropertyExpr_«varIdx»;
        }
	«ENDLET»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName, String resultType, ParsedResource resource) FOR SwitchExpression»
	«LET getNextVarIdx() AS varIdx»
		List<Pair<Function, Function>> cases = new ArrayList<Pair<Function, Function>> ();
		«FOREACH cases AS c ITERATOR it-»
		Function «resultVarName»_Cond_«it.counter1» = new AbstractClosure(_ctx.getLocalVarContext(), _ctx.getFunctionDefContext(), new ArrayList<String> (), new ArrayList<BackendType>()) {
			
			@Override
			protected Object apply(ExecutionContext ctx) {
				«EXPAND compileExpression (c.firstAsObject.getVarName (resultVarName + "_CondResult", "_" +it.counter1), "Object", resource) FOR c.firstAsObject-»
				return «c.firstAsObject.getVarName (resultVarName + "_CondResult", "_" +it.counter1)»;
			}
		};
		Function «resultVarName»_Yield_«it.counter1» = new AbstractClosure(_ctx.getLocalVarContext(), _ctx.getFunctionDefContext(), new ArrayList<String> (), new ArrayList<BackendType>()) {
			
			@Override
			protected Object apply(ExecutionContext ctx) {
				«EXPAND compileExpression (c.secondAsObject.getVarName (resultVarName + "_YieldResult", "_" +it.counter1), "Object", resource) FOR c.secondAsObject-»
				return «c.secondAsObject.getVarName (resultVarName + "_YieldResult", "_" +it.counter1)»;
			}
		};
		Pair<Function, Function> «resultVarName»_Case_«it.counter1» = new Pair<Function, Function> («resultVarName»_Cond_«it.counter1», «resultVarName»_Yield_«it.counter1»);
		cases.add («resultVarName»_Case_«it.counter1»);
		«ENDFOREACH-»
		Object «resultVarName» = null;
		for (Pair<Function, Function> curCase : cases) {
            final Object curVal = curCase.getFirst().invoke(_ctx, new Object[0]);
            
            if (Helpers.nullSafeEquals (_ctx, «switchExpr.getVarName ("switchExpr", "_" +varIdx)», curVal)) {
            	«resultVarName» = curCase.getSecond().invoke(_ctx, new Object[0]);
            	break;
            }
		}
	«ENDLET»
«ENDDEFINE»


«DEFINE compileAdvice(String resultVarName, ParsedResource resource) FOR AroundAdvice»
	«LET getNextVarIdx() AS varIdx»
		AroundAdvice «resultVarName» = new AroundAdvice (bodyVarName_«varIdx», pointcutVarName_«varIdx», «cacheable»);
		@M2tAroundAdvice (pointcut=«EXPAND compilePointcut (resource) FOR pointcut»)
	«ENDLET»
«ENDDEFINE»

«DEFINE compilePointcut (ParsedResource resource) FOR Pointcut»
«ENDDEFINE»

«DEFINE compilePointcut (ParsedResource resource) FOR ExecutionPointcut»
	«LET getNextVarIdx() AS varIdx»
		@M2tPointcut (namePattern = "«functionNamePattern»" , «EXPAND compileAdviceParamTypes (resource) FOR paramTypes», hasVarArgs = «hasVarArgs»
	«ENDLET»
«ENDDEFINE»

«DEFINE compileAdviceParamTypes (ParsedResource resource) FOR List[Pair]»
	«LET getNextVarIdx() AS varIdx»
		paramTypeNames={"«FOREACH this AS e SEPARATOR ", "»"«((AdviceParamType)e.secondAsObject).type.name»"«ENDFOREACH»}
	«ENDLET»
«ENDDEFINE»
