«IMPORT org::eclipse::xtend::backend::aop»
«IMPORT org::eclipse::xtend::backend::common»
«IMPORT org::eclipse::xtend::backend::expr»
«IMPORT org::eclipse::xtend::backend::functions»
«IMPORT org::eclipse::xtend::backend::util»
«IMPORT org::eclipse::xtend::backend::compiler»
«IMPORT org::eclipse::xtend::middleend::javaannotations::internal»

«EXTENSION org::eclipse::xtend::backend::compiler::templates::expressions»
«EXTENSION org::eclipse::xtend::backend::compiler::templates::names»

«DEFINE compileExpression(String resultVarName) FOR Object»
«ENDDEFINE»
«DEFINE compileExpression(String resultVarName) FOR ExpressionBase»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR AndExpression»
	«LET getNextVarIdx() AS varIdx»
		«EXPAND compileExpression ("leftVarName_"+varIdx) FOR left»
		«EXPAND compileExpression ("rightVarName_"+varIdx) FOR right»
		if (leftVarName_«varIdx» && rightVarName_«varIdx»)
			«resultVarName» = true;
		else 
			«resultVarName» = false;
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR ConcatExpression»
	«LET getNextVarIdx() AS varIdx»
		List<? extends ExpressionBase> partListVarName_«varIdx» = new ArrayList<ExpressionBase>();
        EfficientLazyString «resultVarName» = new EfficientLazyString ();
		«FOREACH parts AS p ITERATOR it»
			«EXPAND compileExpression ("concatPart_"+ varIdx + "_" +it.counter0) FOREACH parts»
			if (concatPart_«varIdx»_«it.counter0» instanceof CharSequence)
        		«resultVarName» = EfficientLazyString.createAppendedString («resultVarName», Helpers.overridableToString (_ctx, concatPart_«varIdx»_«it.counter0»));
        	else if (concatPart_«varIdx»_«it.counter0» instanceof FutureResultHolder && !((FutureResultHolder)res).isReady())
        		«resultVarName» = EfficientLazyString.createAppendedString («resultVarName», concatPart_«varIdx»_«it.counter0»);
        	else
        		result = EfficientLazyString.createAppendedString (result, Helpers.overridableToString (_ctx, concatPart_«varIdx»_«it.counter0»));
		«ENDFOREACH»
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR CreateCachedExpression»
	«LET getNextVarIdx() AS varIdx»
        final List<Object> params = new ArrayList<Object>();
        
		«FOREACH paramExpr AS p ITERATOR it»
			«EXPAND compileExpression ("createParamVarName_"+ varIdx + "_" +it.counter0) FOREACH paramExpr»
			params.add ( createParamVarName_«varIdx»_«it.counter0»);
		«ENDFOREACH»
        
        «resultVarName» = _ctx.getCreationCache().createRaw (ts.findType («type.uniqueRepresentation»), params);
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR CreateUncachedExpression»
		«resultVarName» = ts.findType («type.uniqueRepresentation»).create()
«ENDDEFINE»

«REM»
TODO Get the function somehow
«ENDREM»
«DEFINE compileExpression(String resultVarName) FOR CurryingExpression»
	«LET getNextVarIdx() AS varIdx»
		Function function_«varIdx» = 
		List<? extends ExpressionBase> boundParamVarName_«varIdx» = new ArrayList<ExpressionBase>();
		«FOREACH boundParams.typeSelect(ExpressionBase) AS p ITERATOR it»
			«EXPAND compileExpression("boundParamVarName_" + varIdx + "_" + it.counter1) FOR p»
			boundParamsVarName.add(boundParamVarName_«varIdx»_«it.counter1»);
		«ENDFOREACH»
		CurriedFunction «resultVarName» = new CurriedFunction (function_«varIdx», boundParamVarName_«varIdx», _ctx) 
	«ENDLET»
«ENDDEFINE»

«REM»
TODO
«ENDREM»
«DEFINE compileExpression(String resultVarName) FOR DeferredEvalExpression»
	«LET getNextVarIdx() AS varIdx»
		«EXPAND compileExpression ("deferredExprVarName_"+varIdx) FOR innerExpr»
		ExpressionBase «resultVarName» = new DeferredEvalExpression (deferredExprVarName_«varIdx», «pos.buildSourcePos()»);
	«ENDLET»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName) FOR HidingLocalVarDefExpression»
	«LET getNextVarIdx() AS varIdx»
        final Object oldValue_«varIdx» = _ctx.getLocalVarContext().getLocalVars().get(«localVarName»);
        «EXPAND compileExpression ("defExprResult_" + varIdx) FOR defExpression» 
        _ctx.getLocalVarContext().getLocalVars().put («localVarName», defExprResult_«varIdx»);

        if (_ctx.isLogStacktrace())
            _ctx.getStacktrace().add (new StacktraceEntry («pos.buildSourcePos()», _ctx));

        try {
			«EXPAND compileExpression ("innerExprVarName_" + varIdx) FOR innerExpression»
            «resultVarName» = innerExprVarName_«varIdx»;
        }
        finally {
            _ctx.getStacktrace ().remove (_ctx.getStacktrace().size() - 1);
            _ctx.getLocalVarContext().getLocalVars().put(«localVarName», oldValue_«varIdx»);
        }
	«ENDLET»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName) FOR IfExpression»
	«LET getNextVarIdx() AS varIdx»
		«EXPAND compileExpression ("condExprVarName_" + varIdx) FOR condition»
		if (condExprVarName_«varIdx») {
		«EXPAND compileExpression ("ifExprVarName_" + varIdx) FOR ifPart»
		} else {
		«EXPAND compileExpression ("elseExprVarName_" + varIdx) FOR elsePart»
		}
	«ENDLET»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName) FOR InitClosureExpression»
	«LET getNextVarIdx() AS varIdx»
		List<String> paramNamesVarName_«varIdx» = Arrays.asList («FOREACH paramNames AS p SEPARATOR ","»«p»«ENDFOREACH»);
		List<? extends BackendType> paramTypesVarName_«varIdx» = new ArrayList<BackendType();
		«FOREACH paramTypes.typeSelect(BackendType) AS pt»
			paramTypesVarName.add (ts.findType («pt.uniqueRepresentation»));
		«ENDFOREACH»
		«EXPAND compileExpression ("defExprVarName_" +varIdx) FOR defExpression»
		Closure «resultVarName» = new InitClosureExpression (paramNamesVarName_«varIdx», paramTypesVarName_«varIdx», defExprVarName_«varIdx», «pos.buildSourcePos()»);
	«ENDLET»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName) FOR InvocationOnCollectionExpression»
	«LET getNextVarIdx() AS varIdx»
        Collection<?> coll_«varIdx» = null;
        «EXPAND compileExpression ("coll_" +varIdx) FOR collection»(Collection<?>) _coll.evaluate(_ctx);
        «IF params.size > 0 && LocalVarEvalExpression.isInstance(params.first())»
        	«IF (((LocalVarEvalExpression)params.first()).localVarName == "this")»
        		boolean firstParamIsThis_«varIdx» = true;
        	«ELSE»
		        boolean firstParamIsThis_«varIdx» = false;	
        	«ENDIF»
        «ELSE»
	        boolean firstParamIsThis_«varIdx» = false;
        «ENDIF»
        if (coll_«varIdx» == null) {
            _ctx.logNullDeRef («pos.buildSourcePos()»));
            «resultVarName» = null;
        } else {
	        
	        final List<Object> params_«varIdx» = new ArrayList<Object>();
	        params_«varIdx».add (null); //placeholder
	        «FOREACH params AS e»
	        	Object param_«varIdx» = null;
	        	«EXPAND compileExpression ("param_"+varIdx) FOR e»
	        	params_«varIdx».add (param_«varIdx»);        	
	        «ENDFOREACH»
	        
	        Collection<?> «resultVarName»Coll = CollectionOperations.createMatchingCollection (coll);
	        
	        for (Object o_«varIdx»: coll_«varIdx») {
	        	params_«varIdx».set (0, o_«varIdx»);
	
	        	CollectionOperations.addFlattened («resultVarName»Coll, _ctx.getFunctionDefContext().invoke (_ctx, «functionName.getQualifiedNameBuilder()», params_«varIdx», firstParamIsThis_«varIdx»));
	        }
	        
	        «resultVarName» = «resultVarName»Coll;
        }
	«ENDLET»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName) FOR InvocationOnObjectExpression»
	«LET getNextVarIdx() AS varIdx»
		Object paramExprVarName_«varIdx» = null;
        «REM»MATCH THE TWO OF THEM«ENDREM» 
        final List<Object> params_«varIdx» = new ArrayList<Object> ();
        «IF params.size > 0 && LocalVarEvalExpression.isInstance(params.first())»
        	«IF (((LocalVarEvalExpression)params.first()).localVarName == "this")»
        		boolean firstParamIsThis_«varIdx» = true;
        	«ELSE»
		        boolean firstParamIsThis_«varIdx» = false;	
        	«ENDIF»
        «ELSE»
	        boolean firstParamIsThis_«varIdx» = false;
        «ENDIF»
        «FOREACH params AS e ITERATOR it»
        	«EXPAND compileExpression ("paramExprRes_"+varIdx+"_"+it.counter1) FOR e»
        	params_«varIdx».add (paramExprRes_«varIdx»_«it.counter1»);
        «ENDFOREACH»
        «IF nullIfFirstParamIsNull && params.size > 0»
        if(params_«varIdx».get(0) == null) {
            _ctx.logNullDeRef («pos.buildSourcePos()»);
            «resultVarName» = null;
        } else {
        	«resultVarName» =  _ctx.getFunctionDefContext().invoke (_ctx, «functionName.getQualifiedNameBuilder()», params_«varIdx», firstParamIsThis_«varIdx»);
		}
        «ELSE»
        «resultVarName» =  _ctx.getFunctionDefContext().invoke (_ctx, «functionName.getQualifiedNameBuilder()», params_«varIdx», firstParamIsThis_«varIdx»);
        «ENDIF»
        
	«ENDLET»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName) FOR InvocationOnWhateverExpression»
	«LET getNextVarIdx() AS varIdx»
        «IF params.size > 0 && LocalVarEvalExpression.isInstance(params.first())»
        	«IF (((LocalVarEvalExpression)params.first()).localVarName == "this")»
        		boolean firstParamIsThis_«varIdx» = true;
        	«ELSE»
		        boolean firstParamIsThis_«varIdx» = false;	
        	«ENDIF»
        «ELSE»
	        boolean firstParamIsThis_«varIdx» = false;
        «ENDIF»
        «FOREACH params AS e ITERATOR it»
        	«EXPAND compileExpression ("paramExprRes_"+varIdx+"_"+it.counter1) FOR e»
        	params_«varIdx».add (paramExprRes_«varIdx»_«it.counter1»);
        «ENDFOREACH»

        «IF nullIfFirstParamIsNull && params.size > 0»
        if (_nullIfFirstParamIsNull && params.get(0) == null) {
            _ctx.logNullDeRef (getPos());
            «resultVarName» = null;
        } else {
	        if (params_«varIdx».get (0) instanceof Collection<?>) {
	            // check if this is a function on Collection itself
	            if (_ctx.getFunctionDefContext().hasMatch (_ctx, «functionName.getQualifiedNameBuilder()», params_«varIdx»))
	                return _ctx.getFunctionDefContext().invoke (_ctx, _functionName, params_«varIdx», firstParamIsThis_«varIdx»);
	
	            final Collection<?> coll_«varIdx» = (Collection<?>) params_«varIdx».get (0);
	            
	            Collection<?> «resultVarName»Coll = CollectionOperations.createMatchingCollection (coll_«varIdx»);
	            
	            for (Object o_«varIdx»: coll_«varIdx») {
	                params_«varIdx».set (0, o_«varIdx»);
	                
	                CollectionOperations.addFlattened («resultVarName»Coll, _ctx.getFunctionDefContext().invoke (_ctx, «functionName.getQualifiedNameBuilder()», params_«varIdx», firstParamIsThis_«varIdx»));
	            }
	            
	            «resultVarName» = «resultVarName»Coll;
	        }
	        else 
	            «resultVarName» =  _ctx.getFunctionDefContext().invoke (_ctx, «functionName.getQualifiedNameBuilder()», params_«varIdx», firstParamIsThis_«varIdx»);
        }
        «ELSE»
	        if (params_«varIdx».get (0) instanceof Collection<?>) {
	            // check if this is a function on Collection itself
	            Collection<?> «resultVarName»Coll = null;
	            if (_ctx.getFunctionDefContext().hasMatch (_ctx, «functionName.getQualifiedNameBuilder()», params_«varIdx»))
	                return _ctx.getFunctionDefContext().invoke (_ctx, «functionName.getQualifiedNameBuilder()», params_«varIdx», firstParamIsThis_«varIdx»);
	
	            final Collection<?> coll_«varIdx» = (Collection<?>) params_«varIdx».get (0);
	            
	            Collection<?> «resultVarName»Coll = CollectionOperations.createMatchingCollection (coll_«varIdx»);
	            
	            for (Object o_«varIdx»: coll_«varIdx») {
	                params_«varIdx».set (0, o_«varIdx»);
	                
	                CollectionOperations.addFlattened («resultVarName»Coll, _ctx.getFunctionDefContext().invoke (_ctx, «functionName.getQualifiedNameBuilder()», params_«varIdx», firstParamIsThis_«varIdx»));
	            }
	            «resultVarName» = «resultVarName»Coll;
	
	        }
	        else 
	            «resultVarName» =  _ctx.getFunctionDefContext().invoke (_ctx, «functionName.getQualifiedNameBuilder()», params_«varIdx», firstParamIsThis_«varIdx»);
        «ENDIF»
	«ENDLET»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName) FOR ListLiteralExpression»
	«LET getNextVarIdx() AS varIdx»
		ExpressionBase «resultVarName» = new ListLiteralExpression (listExprVarName_«varIdx», «pos.buildSourcePos()»);

        final List<Object> result = new ArrayList<Object>();
        
        «FOREACH innerExpression AS e ITERATOR it»
        	«EXPAND compileExpression ("exprRes_"+ varIdx + "_" + it) FOR e»
        	«resultVarName».add (exprRes_«varIdx»);
        «ENDFOREACH»
	«ENDLET»
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName) FOR LiteralExpression»
		«resultVarName» = «value»;
«ENDDEFINE»


«DEFINE compileExpression(String resultVarName) FOR LocalVarEvalExpression»
		«resultVarName» = _ctx.getLocalVarContext().getLocalVars().get ("«localVarName»");
«ENDDEFINE»

«REM»FIX THIS«ENDREM»
«DEFINE compileExpression(String resultVarName) FOR MethodInvocationExpression»
	«LET getNextVarIdx() AS varIdx»
		Class cls = «method.declaringClass.name».class;
		«IF method.parameterTypes.size > 0»
			Method mtd = cls.getMethod(«method.name», «FOREACH method.parameterTypes AS pt SEPARATOR ", "»«pt.name»«ENDFOREACH»);
		«ELSE»
			Method mtd = cls.getMethod(«method.name»);
		«ENDIF»
		List<? extends ExpressionBase> paramVarName_«varIdx» = new ArrayList<ExpressionBase>();
		«FOREACH params.typeSelect(ExpressionBase) AS p ITERATOR it»
			«EXPAND compileExpression("paramVarName_" + varIdx + "_" +it.counter1) FOR p»
			paramVarName.add(paramVarName_«varIdx»_«it.counter1»);
		«ENDFOREACH»
		ExpressionBase «resultVarName» = new MethodInvocationExpression (mtd, paramVarName_«varIdx», «nullIfFirstParamIsNull», «pos.buildSourcePos()»);
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR NewLocalVarDefExpression»
	«LET getNextVarIdx() AS varIdx»
		Object defExpr_«varIdx» = null;
		«EXPAND compileExpression ("defExpr_" + varIdx) FOR defExpression»
        _ctx.getLocalVarContext().getLocalVars().put («localVarName», defExpr_«varIdx»);

        if (_ctx.isLogStacktrace())
            _ctx.getStacktrace().add (new StacktraceEntry («pos.buildSourcePos()», _ctx));
        
        try {
        	Object innerNewLocalVarDefExpr_«varIdx» = null;
        	«EXPAND compileExpression ("innerNewLocalVarDefExpr_"+varIdx ) FOR innerExpression»
        }
        finally {
            if (_ctx.isLogStacktrace())
                _ctx.getStacktrace ().remove (_ctx.getStacktrace().size() - 1);
            _ctx.getLocalVarContext ().getLocalVars ().remove («localVarName»);
        }
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR OrExpression»
	«LET getNextVarIdx() AS varIdx»
		«EXPAND compileExpression ("leftVarName_" +varIdx) FOR left»
		«EXPAND compileExpression ("rightVarName_" +varIdx) FOR right»
		boolean «resultVarName» = false;
		if (leftVarName_«varIdx» || rightVarName_«varIdx»)
			«resultVarName» = true;
		else
			«resultVarName» = false;
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR PropertyOnCollectionExpression»
	«LET getNextVarIdx() AS varIdx»
        Object coll_«varIdx» = null;
        «EXPAND compileExpression ("coll_"+varIdx ) FOR innerExpression»
        if (coll_«varIdx» == null) {
            _ctx.logNullDeRef («pos.buildSourcePos()»);
            «resultVarName» = null;
        } else {
	        Collection<?> «resultVarName»Coll = CollectionOperations.createMatchingCollection (coll_«varIdx»); 
	
	        if (_log.isDebugEnabled())
	            _log.debug ("evaluating property «propertyName» on collection " + coll_«varIdx»);
	        
	        for (Object o_«varIdx»: coll_«varIdx») 
	            CollectionOperations.addFlattened («resultVarName»Coll, _ctx.getTypesystem().findType(o_«varIdx»).getProperty(_ctx, o_«varIdx», "«propertyName»"));
	        «resultVarName» = «resultVarName»Coll;
        }
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR PropertyOnObjectExpression»
	«LET getNextVarIdx() AS varIdx»
		Object innerPropertyOnObjectExpr_«varIdx» = null;
		«EXPAND compileExpression ("innerPropertyOnObjectExpr_" + varIdx) FOR innerExpression»
        if (innerPropertyOnObjectExpr_«varIdx» == null) {
            _ctx.logNullDeRef («pos.buildSourcePos()»);
            «resultVarName» = null;
        } else {
       		«resultVarName» = _ctx.getTypesystem().findType (innerPropertyOnObjectExpr_«varIdx»).getProperty (_ctx, innerPropertyOnObjectExpr_«varIdx», "«propertyName»");
       	}
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR PropertyOnWhateverExpression»
	«LET getNextVarIdx() AS varIdx»
		Object innerPropertyExpr_«varIdx» = null;
		«EXPAND compileExpression ("innerPropertyExpr_" + varIdx) FOR innerExpression»
        if (innerPropertyExpr_«varIdx» == null) {
            _ctx.logNullDeRef («pos.buildSourcePos()»);
            «resultVarName» =  null;
        } else {
	        final BackendType t_«varIdx» = _ctx.getTypesystem().findType (innerPropertyExpr_«varIdx»);
	        
	        if (CollectionType.INSTANCE.isAssignableFrom(t_«varIdx»)) {
	            if (isProperty (_ctx, t_«varIdx», "«propertyName»"))
	                «resultVarName» = t_«varIdx».getProperty (_ctx, innerPropertyExpr_«varIdx», "«propertyName»");
	            
	           	Collection<?> «resultVarName»Coll = CollectionOperations.createMatchingCollection ((Collection<?>) innerPropertyExpr_«varIdx»);
	
	            for (Object obj_«varIdx»: (Collection<?>) innerPropertyExpr_«varIdx») 
	                CollectionOperations.addFlattened («resultVarName»Coll, _ctx.getTypesystem().findType(obj_«varIdx»).getProperty(_ctx, obj_«varIdx», "«propertyName»"));
	            «resultVarName» = «resultVarName»Coll;
	        }
	        else
	            «resultVarName» = t_«varIdx».getProperty (_ctx, innerPropertyExpr_«varIdx», "«propertyName»");
        }
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR RegisterAdviceExpression»
	«LET getNextVarIdx() AS varIdx»
		«EXPAND compileExpression ("innerVarName_" +varIdx) FOR innerExpression»
		«EXPAND compileAdvice ("advVarName_" +varIdx) FOR advice»
		ExpressionBase «resultVarName» = new RegisterAdviceExpression (innerVarName_«varIdx», «pos.buildSourcePos()»);

        final AdviceContext oldContext_«varIdx» = _ctx.getAdviceContext();
        
        _ctx.setAdviceContext (_ctx.getAdviceContext ().copyWithAdvice (_advice));
        try {
			Object innerRegisterAdviceExpr_«varIdx» = null;
			«EXPAND compileExpression ("innerRegisterAdviceExpr_" + varIdx) FOR innerExpression»
            «resultVarName» = innerRegisterAdviceExpr_«varIdx»;
        }
        finally {
            _ctx.setAdviceContext (oldContext_«varIdx»);
        }
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR SequenceExpression»
	«LET getNextVarIdx() AS varIdx»
        «resultVarName» = null;
        
        «FOREACH inner AS e ITERATOR it»
        	«EXPAND compileExpression ("exprRes_"+ varIdx + "_" + it) FOR e»
        	«IF it.lastIteration»
	        	«resultVarName» = exprRes_«varIdx»;
        	«ENDIF»
        «ENDFOREACH»
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR SetPropertyExpression»
	«LET getNextVarIdx() AS varIdx»
		«EXPAND compileExpression ("innerVarName_" +varIdx) FOR innerExpression»
		«EXPAND compileExpression ("valueExprVarName_" +varIdx) FOR valueExpr»
		ExpressionBase «resultVarName» = new SetPropertyExpression (innerVarName_«varIdx», «propertyName», valueExprVarName_«varIdx», «pos.buildSourcePos()»);

		Object innerSetPropertyExpr_«varIdx» = null;
		«EXPAND compileExpression ("innerPropertyExpr_" + varIdx) FOR innerExpression»
        if (innerSetPropertyExpr_«varIdx» == null) {
            _ctx.logNullDeRef («pos.buildSourcePos()»);
            «resultVarName» =  null;
        } else {
        
	        final BackendType t_«varIdx» = _ctx.getTypesystem().findType(o);
			Object value_«varIdx» = null;
			«EXPAND compileExpression ("value_" + varIdx) FOR valueExpr»
	        t_«varIdx».setProperty (_ctx, innerSetPropertyExpr_«varIdx», "«propertyName»", value_«varIdx»);
	        
	        «resultVarName» = innerSetPropertyExpr_«varIdx»;
        }
	«ENDLET»
«ENDDEFINE»

«DEFINE compileExpression(String resultVarName) FOR SwitchExpression»
	«LET getNextVarIdx() AS varIdx»
		«EXPAND compileExpression ("switchExprVarName_" +varIdx) FOR switchExpr»
		«EXPAND compileExpression ("casesVarName_" +varIdx) FOREACH cases»
		«EXPAND compileExpression ("defaultVarName_" +varIdx) FOR defaultExpr»
		ExpressionBase «resultVarName» = new SwitchExpression (switchExprVarName_«varIdx», casesVarName_«varIdx», defaultVarName_«varIdx», «pos.buildSourcePos()»);

		Object switchVal_«varIdx» = null;
		«EXPAND compileExpression ("switchVal_" + varIdx) FOR switchExpr»
        «REM»Closures would be perfect here!!!«ENDREM»
        for (Pair<ExpressionBase, ExpressionBase> curCase: _cases) {
            final Object curVal = curCase.getFirst().evaluate(_ctx);
                
            if (Helpers.nullSafeEquals (_ctx, switchVal, curVal))
                return curCase.getSecond().evaluate(_ctx);
        }
        
        return _defaultExpr.evaluate(_ctx);
	«ENDLET»
«ENDDEFINE»

«DEFINE compileAdvice(String resultVarName) FOR AroundAdvice»
	«LET getNextVarIdx() AS varIdx»
		AroundAdvice «resultVarName» = new AroundAdvice (bodyVarName_«varIdx», pointcutVarName_«varIdx», «cacheable»);
		@M2tAroundAdvice (pointcut=«EXPAND compilePointcut FOR pointcut»)
	«ENDLET»
«ENDDEFINE»

«DEFINE compilePointcut FOR Pointcut»
«ENDDEFINE»

«DEFINE compilePointcut FOR ExecutionPointcut»
	«LET getNextVarIdx() AS varIdx»
		@M2tPointcut (namePattern = «functionNamePattern» , «EXPAND compileAdviceParamTypes FOR paramTypes», hasVarArgs = «hasVarArgs»
	«ENDLET»
«ENDDEFINE»

«DEFINE compileAdviceParamTypes FOR List[Pair]»
	«LET getNextVarIdx() AS varIdx»
		paramTypeNames={«FOREACH this AS e SEPARATOR ", "»"«((AdviceParamType)e.secondAsObject).type.name»"«ENDFOREACH»}
	«ENDLET»
«ENDDEFINE»
